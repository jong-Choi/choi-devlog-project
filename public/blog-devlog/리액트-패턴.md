좋아. 여기 React에서 자주 쓰이는 핵심 패턴들과 개념들, 그리고 너가 아직 안 짚고 간 내용들까지 총정리해줄게. 이건 진짜 중고급 이상 React 개발자라면 반드시 체화해야 하는 내용들이라 개발 일지로 정리해도 좋아.

---

## ✅ **React 핵심 패턴 & 개념 정리**

---

### 🔹 1. **Render Props**

```tsx
type RenderProps = {
  children: (props: { value: string }) => ReactNode;
};

function Example({ children }: RenderProps) {
  const value = "Hello";
  return <div>{children({ value })}</div>;
}
```

- `children`이 함수형태로 넘어오는 패턴
- `onClose` 같은 제어권을 하위로 위임할 때 유용
- **장점**: 제어권을 내려주되, 상위 컴포넌트에서 context를 유지함

---

### 🔹 2. **Null 병합 연산자 `??`**

```ts
const username = user.name ?? "게스트";
```

- `null` 또는 `undefined`일 때만 기본값 설정
- `||`와 다르게 `0`, `''`, `false`는 유지

---

### 🔹 3. **Wrapper Function 패턴 (래퍼 함수 패턴)**

```ts
const withLogging = <T extends (...args: any[]) => any>(fn: T): T => {
  return ((...args: any[]) => {
    console.log("실행됨", args);
    return fn(...args);
  }) as T;
};
```

- 주로 **캐싱**, **로깅**, **권한 체크**, **성능 추적** 등에 사용
- `unstable_cache`, `createWithInvalidation`, `withErrorHandler` 등도 이 형태

---

### 🔹 4. **함수형 Children (Function as Child)**

- Render Props랑 유사하지만 **더 추상적**

```tsx
<Component>
  {({ open, toggle }) => (
    <button onClick={toggle}>{open ? "닫기" : "열기"}</button>
  )}
</Component>
```

- 복잡한 UI 상호작용을 외부에서 자유롭게 정의할 수 있음

---

### 🔹 5. **Compound Components (복합 컴포넌트)**

```tsx
<Tabs>
  <Tabs.List>
    <Tabs.Trigger value="a">탭 A</Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content value="a">내용 A</Tabs.Content>
</Tabs>
```

- 관련된 컴포넌트들을 **논리적 그룹**으로 관리
- 내부에서 context로 상태 공유

---

### 🔹 6. **Controlled vs Uncontrolled Component**

```tsx
// Controlled
<input value={value} onChange={(e) => setValue(e.target.value)} />
// Uncontrolled
<input defaultValue="hello" />
```

- Controlled: 상태를 부모가 소유
- Uncontrolled: 내부 DOM이 상태 소유

---

### 🔹 7. **Context API + 커스텀 훅 조합**

```ts
const MyContext = createContext(null);
export const useMy = () => useContext(MyContext);
```

- **전역 상태 관리**의 핵심 패턴
- ShadCN, Zustand, Recoil 등을 다룰 때 기초가 됨

---

### 🔹 8. **Error Boundaries**

- `componentDidCatch` / `getDerivedStateFromError`
- 또는 [React 18 이후 → `use` 기반 에러 경계 + Suspense 조합]

```tsx
<ErrorBoundary fallback={<ErrorUI />}>
  <Suspense fallback={<Loading />}>
    <MyComponent />
  </Suspense>
</ErrorBoundary>
```

---

### 🔹 9. **Revalidation / Cache Pattern**

- Next.js App Router에서 자주 쓰는 패턴

```ts
unstable_cache(fn, [key], { revalidate, tags });
```

- → `createCachedFunction`, `createWithInvalidation` 이런 식으로 래핑

---

### 🔹 10. **Slot-based Pattern** (shadcn 등에서 자주 쓰임)

```tsx
<Dialog>
  <DialogTrigger asChild>
    <Button>열기</Button>
  </DialogTrigger>
  <DialogContent>내용</DialogContent>
</Dialog>
```

- `asChild`로 slot-like 구성
- headless UI 구성에 최적화됨

---

### 🔹 11. **Suspense + Async Server Component + `use`**

- App Router에서 SSR 데이터 처리 방식

```tsx
const posts = await fetchPosts();
return <PostList data={posts} />;
```

- 또는 `use(fetchPosts())` ← React 18 이상에서만 가능

---

### 🔹 12. **Shallow Routing & URL 상태**

- `useSearchParams`, `window.history.pushState`
- 상태를 URL에 반영 (but SSR 영향 없음)

---

오케이, 완전 종합 정리해줄게. 이건 실전 React 개발에서 자주 등장하는 **핵심 패턴/기법 모음집**이라 보면 돼.  
디자인 원칙 + React 특화 패턴 + 코드 구조화 기법까지 싹 정리할게:

---

## 🧠 **React 핵심 패턴/기법 총정리**

### 📦 **1. Component Composition 패턴**

> 컴포넌트를 조합하고 구조화하는 방법들

| 패턴 이름                              | 설명                                    | 대표 예시                                                   |
| -------------------------------------- | --------------------------------------- | ----------------------------------------------------------- |
| **Children as Props**                  | `props.children`으로 자식 요소 전달     | `<Modal>내용</Modal>`                                       |
| **Render Props**                       | `children`을 함수로 받아 렌더링         | `{children => <div>{children(state)}</div>}`                |
| **Function as Child Component (FaCC)** | 위와 거의 같지만 패턴 강조              | `<MyComponent>{(data) => <UI data={data} />}</MyComponent>` |
| **Compound Components**                | 하위 컴포넌트를 상위에서 context로 공유 | `<Tabs><Tabs.List /><Tabs.Panel /></Tabs>`                  |
| **Slot pattern (asChild)**             | 부모의 DOM을 직접 제어하게 위임         | ShadCN의 `asChild`, Radix UI                                |
| **Wrapper Component**                  | 특정 역할을 감싸는 컴포넌트             | `<AuthProvider>{children}</AuthProvider>`                   |

---

### ⚙️ **2. 상태 관리 & 데이터 흐름 패턴**

| 패턴 이름                   | 설명                                 | 대표 예시                                                  |
| --------------------------- | ------------------------------------ | ---------------------------------------------------------- |
| **Controlled Components**   | 상태를 부모가 제어                   | `<input value={state} onChange={...} />`                   |
| **Uncontrolled Components** | ref를 이용해 직접 DOM 접근           | `<input ref={myRef} />`                                    |
| **State Reducer Pattern**   | 상태 변화를 외부에서 조작 가능하게   | `useReducer`, downshift 스타일                             |
| **Lift State Up**           | 자식 컴포넌트 상태를 부모로 끌어올림 | `<Form><Input value={value} onChange={setValue} /></Form>` |
| **Global State with Hooks** | Context, Zustand, Jotai 등           |

---

### 🔁 **3. 고급 구성 기법 (Advanced Patterns)**

| 패턴 이름                          | 설명                                 | 대표 예시                                   |
| ---------------------------------- | ------------------------------------ | ------------------------------------------- |
| **Higher Order Component (HOC)**   | 컴포넌트를 감싸 기능 추가            | `withAuth(Component)`                       |
| **Custom Hook**                    | 재사용 가능한 로직 추출              | `useForm`, `useToggle`, `useSidebarStore`   |
| **Hook Factory**                   | 동적으로 훅 생성                     | `createUseStore(namespace)`                 |
| **Portal Pattern**                 | 컴포넌트를 다른 DOM 계층에 렌더링    | `<Modal>`, `<Toast />`                      |
| **Headless Component Pattern**     | UI 없는 기능만 제공                  | Radix UI, Headless UI                       |
| **Dependency Injection via Props** | 의존성 주입처럼 함수나 컴포넌트 주입 | `renderItem={(item) => <Item {...item} />}` |

---

### 🧩 **4. 동적/비동기 렌더링 패턴**

| 패턴 이름                 | 설명                                 | 대표 예시                               |
| ------------------------- | ------------------------------------ | --------------------------------------- |
| **Suspense + Lazy**       | 지연 로딩 처리                       | `React.lazy`, `Suspense fallback`       |
| **Skeleton Pattern**      | 뼈대 UI 먼저 보여주기                | `<Skeleton />`                          |
| **Progressive Hydration** | 서버-클라이언트 점진적 연동          | Next.js App Router 방식                 |
| **Boundary Pattern**      | 에러 바운더리 / Suspense 바운더리 등 | `<ErrorBoundary><UI /></ErrorBoundary>` |

---

### 🔧 **5. 유틸 기반 패턴**

| 패턴 이름                            | 설명                       | 대표 예시                                          |
| ------------------------------------ | -------------------------- | -------------------------------------------------- |
| **Wrapper 함수 패턴**                | 함수/로직 감싸서 기능 추가 | `withLogging(fn)`                                  |
| **캐시 래퍼 패턴**                   | 결과 캐싱                  | `unstable_cache(...)`, `createCachedFunction(...)` |
| **함수형 Composition 패턴**          | 함수 조합                  | `pipe`, `compose`                                  |
| **옵셔널 체이닝 / null 병합 연산자** | 안정성 향상                | `obj?.value ?? "기본값"`                           |

---

### 🌈 **6. 스타일 관련 패턴**

| 패턴 이름                 | 설명                      | 대표 예시                     |
| ------------------------- | ------------------------- | ----------------------------- |
| **CSS-in-JS Pattern**     | JS로 스타일 선언          | styled-components, emotion    |
| **Tailwind Composition**  | 클래스 조합 패턴          | `clsx`, `cn()` 함수           |
| **Scoped Slot + Variant** | 조건부 렌더링 + 상태 조절 | Shadcn의 `variant`, `size` 등 |

---

## ✅ 요약하면…

- **패턴이란?** 특정 문제를 해결하기 위한 **관용적 구성 방식**
- 디자인 패턴은 언어 전반의 철학
- React 패턴은 **UI 상태/구조/조합의 문법적 기교**
- **좋은 패턴은**: 재사용성, 추상화, 확장성, 협업성 확보 가능

---

## 📚 React 핵심 패턴 학습 가이드 - 목차

### 1. 컴포넌트 조합 패턴 (Component Composition Patterns)

- [프레젠테이셔널 & 컨테이너 컴포넌트 패턴 (Presentational & Container Components)](#프레젠테이셔널--컨테이너-컴포넌트-패턴-presentational--container-components)
- [컴파운드 컴포넌트 패턴 (Compound Components)](#컴파운드-컴포넌트-패턴-compound-components)
- [고차 컴포넌트 패턴 (Higher-Order Components, HOC)](#고차-컴포넌트-패턴-higher-order-components-hoc)
- [렌더 프롭 패턴 (Render Props)](#렌더-프롭-패턴-render-props)
- [Atomic 디자인 패턴 (Atomic Design)](#atomic-디자인-패턴-atomic-design)

### 2. 상태 관리 및 데이터 흐름 (State Management & Data Flow)

- [상태 끌어올리기 (Lifting State Up)](#상태-끌어올리기-lifting-state-up)
- [컨트롤드 vs 언컨트롤드 컴포넌트 (Controlled vs Uncontrolled Components)](#컨트롤드-vs-언컨트롤드-컴포넌트-controlled-vs-uncontrolled-components)
- [컨텍스트 & Provider 패턴 (Context API)](#컨텍스트--provider-패턴-context-api)
- [전역 상태 관리 (Flux / Redux 패턴 등)](#전역-상태-관리-flux--redux-패턴-등)
- [파생 상태(Derived State) 및 단일 원본 원칙](#파생-상태derived-state-및-단일-원본-원칙)

### 3. 고급 구성 기법 (Advanced Composition Techniques)

- [커스텀 훅 패턴 (Custom Hooks for Reusable Logic)](#커스텀-훅-패턴-custom-hooks-for-reusable-logic)
- [포털 패턴 (Portal for Overlay Components)](#포털-패턴-portal-for-overlay-components)
- [ref 전달 및 조작 패턴 (Forwarding Refs)](#ref-전달-및-조작-패턴-forwarding-refs)
- [에러 바운더리 (Error Boundary) 패턴](#에러-바운더리-error-boundary-패턴)
- [코드 스플리팅 및 다이나믹 임포트 (React.lazy & Suspense)]

### 4. 비동기 렌더링 (Asynchronous Rendering Patterns)

- (#코드-스플리팅-및-다이나믹-임포트-reactlazy--suspense)
- [Suspense를 활용한 데이터 패칭 (Suspense for Data Fetching)](#suspense를-활용한-데이터-패칭-suspense-for-data-fetching)
- [트랜지션 (Transitions with startTransition)](#트랜지션-transitions-with-starttransition)
- [연기된 값 (Deferred Value)](#연기된-값-deferred-value)
- [React 서버 컴포넌트 (Next.js App Router 패턴)](#react-서버-컴포넌트-nextjs-app-router-패턴)
- [메모이제이션 패턴 (useMemo, useCallback, React.memo)](#메모이제이션-패턴-usememo-usecallback-reactmemo)

### 5. 유틸 기반 패턴 (Utility-based Patterns)

- [커스텀 훅 유틸리티 모음 (Common Utility Hooks)](#커스텀-훅-유틸리티-모음-common-utility-hooks)
- [불변성 및 상태 업데이트 유틸 (Immer 등)](#불변성-및-상태-업데이트-유틸-immer-등)
- [클래스네임 유틸리티 (조건부 스타일 적용)](#클래스네임-유틸리티-조건부-스타일-적용)

### 6. 스타일 패턴 (Styling Patterns)

- [Atomic CSS (Tailwind) 패턴](#atomic-css-tailwind-패턴)
- [Styled-Components / CSS-in-JS 패턴](#styled-components--css-in-js-패턴)
- [기타: 전통 CSS + BEM, Inline Style 등](#기타-전통-css--bem-inline-style-등)

### 7. and more

- [1.5 Slot Pattern (asChild)](#15-slot-pattern-aschild)
- [2.5 Global State with Hooks](#25-global-state-with-hooks)
- [3.3 Hook Factory](#33-hook-factory)
- [3.5 Headless Component Pattern](#35-headless-component-pattern)
- [3.6 Dependency Injection via Props](#36-dependency-injection-via-props)
- [4.2 Skeleton Pattern](#42-skeleton-pattern)
- [4.3 Progressive Hydration](#43-progressive-hydration)
- [6.3 Scoped Slot + Variant](#63-scoped-slot--variant)

# React 핵심 패턴 학습 가이드

React 애플리케이션을 설계하고 구현할 때 자주 사용되는 다양한 패턴들이 있습니다. 이 문서는 **컴포넌트 조합 패턴**, **상태 관리 및 데이터 흐름**, **고급 구성 기법**, **비동기 렌더링**, **유틸 기반 패턴**, **스타일 패턴**의 여섯 가지 카테고리로 나누어 주요 React 패턴들을 정리합니다. 각 패턴마다 **개요와 필요성**, **사용 사례**, **코드 예시 (TypeScript/JSX)**, **언제 사용해야 하는지**, **장점 및 단점**을 상세히 설명합니다. 최신 React 18+와 Next.js 13(App Router) 환경을 기준으로 하며, 실전에서도 바로 응용할 수 있도록 구체적이고 실용적인 내용에 초점을 맞추었습니다.

## 컴포넌트 조합 패턴 (Component Composition Patterns)

컴포넌트 조합 패턴은 **컴포넌트를 합성**하여 재사용성과 확장성을 높이는 설계 기법입니다. React는 상속보다 합성을 통한 코드 재사용을 권장하며 ([Composition vs Inheritance – React - AiDOOS](https://www.aidoos.com/kb/web-react-composition-vs-inheritance--react/?srsltid=AfmBOooCJwrg7zuKrDEVphElHyro10vUJ6RRFyj2MKPMAuCo-BWX1qT5#:~:text=Composition%20vs%20Inheritance%20%E2%80%93%20React,to%20reuse%20code%20between%20components)), 작은 컴포넌트들을 조합하여 복잡한 UI를 구성합니다. 이 섹션에서는 컴포넌트를 구성하고 조합하는 대표적인 패턴들을 살펴봅니다.

### 프레젠테이셔널 & 컨테이너 컴포넌트 패턴 (Presentational & Container Components)

**개요:** 프레젠테이셔널/컨테이너 패턴은 UI 표시와 비즈니스 로직을 분리하기 위한 고전적인 패턴입니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=,stateful%ED%95%9C%20%EA%B2%BD%ED%96%A5)). Dan Abramov가 2015년에 소개하여 널리 알려졌으며, 하나의 기능을 **프레젠테이셔널 컴포넌트**(UI 담당)와 **컨테이너 컴포넌트**(상태/로직 담당)로 분리합니다 ([Container/Presentational Pattern](https://www.patterns.dev/vue/container-presentational/#:~:text=In%202015%2C%20Dan%20Abramov%20wrote,separated%20components%20into%20two%20categories)). 프레젠테이셔널 컴포넌트는 **어떻게 보이는지**에만 집중하고, props로 데이터와 콜백을 받아 화면을 렌더링합니다. 컨테이너 컴포넌트는 **어떻게 동작하는지**를 관리하며, 데이터 페칭이나 상태 관리 등의 로직을 처리한 뒤 프레젠테이셔널 컴포넌트를 감싸서 사용합니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=,stateful%ED%95%9C%20%EA%B2%BD%ED%96%A5)). 이로써 시각적 표현과 기능 로직을 명확히 분리할 수 있습니다.

**사용 사례:** 이 패턴은 복잡한 UI에서 **관심사 분리**가 필요할 때 유용합니다. 예를 들어, 여러 페이지에서 재사용되는 **UI 컴포넌트**(버튼, 리스트 등)를 만들고, 각 페이지별 **컨테이너**에서 데이터 불러오기나 이벤트 처리를 담당하게 할 수 있습니다. UI와 기능을 담당하는 코드가 분리되어 가독성과 유지보수성이 향상됩니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=%EC%9E%A5%EC%A0%90)) ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=,%EB%A7%88%ED%81%AC%EC%97%85%EC%9D%B4%20%ED%8E%B8%EB%A6%AC%2C%20UI%20%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%9D%B4%20%EA%B0%80%EB%8A%A5%ED%95%A8)).

```tsx
// PresentationalComponent.tsx - UI만 담당 (TSX)
type Props = {
  title: string;
  description: string;
  onClose: () => void;
};
export function PresentationalComponent({
  title,
  description,
  onClose,
}: Props) {
  return (
    <div className="modal">
      <h3>{title}</h3>
      <p>{description}</p>
      <button onClick={onClose}>Close</button>
    </div>
  );
}

// ContainerComponent.tsx - 로직만 담당
import { PresentationalComponent } from "./PresentationalComponent";
import { useState, useEffect } from "react";

export function ContainerComponent() {
  const [title, setTitle] = useState("Some Title");
  const [description, setDescription] = useState("");
  useEffect(() => {
    fetch("/api/info")
      .then((res) => res.json())
      .then((data) => setDescription(data.description));
  }, []);

  const handleClose = () => {
    // 비즈니스 로직 처리 (예: 모달 닫기 로그 등)
    console.log("Modal closed");
  };

  return (
    <PresentationalComponent
      title={title}
      description={description}
      onClose={handleClose}
    />
  );
}
```

**언제 사용해야 하나:** 대규모 애플리케이션에서 컴포넌트의 **역할을 명확히 구분**해야 할 때 사용합니다. UI 변경과 로직 변경을 독립적으로 할 수 있어 협업에 유리합니다. 예를 들어, **디자인 팀과 개발 팀이 분업**해야 한다면, 디자인 팀은 Presentational 컴포넌트만, 개발 팀은 Container 컴포넌트만 수정하도록 할 수 있습니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=%EC%9E%A5%EC%A0%90)) ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=,%EB%90%98%EB%AF%80%EB%A1%9C%20%EC%B6%A9%EB%8F%8C%EC%9D%84%20%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%9D%8C)). 또한 여러 곳에서 쓰이는 공통 UI 컴포넌트를 만들고, 화면별로 다른 데이터 소스를 연결해야 할 때도 이 패턴이 유용합니다.

**장점:**

- **관심사 분리:** UI 코드와 상태/로직 코드가 분리되어 **복잡도가 감소**하고 유지보수가 쉬워집니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=%EC%9E%A5%EC%A0%90)).
- **UI 재사용성:** 동일한 Presentational 컴포넌트를 다양한 컨텍스트에서 재사용 가능하므로 **컴포넌트 재사용성**이 높아집니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=,%EB%A7%88%ED%81%AC%EC%97%85%EC%9D%B4%20%ED%8E%B8%EB%A6%AC%2C%20UI%20%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%9D%B4%20%EA%B0%80%EB%8A%A5%ED%95%A8)).

**단점:**

- **패턴의 경직성:** Hooks 도입 이후, 이 패턴을 지나치게 엄격히 적용할 필요는 줄어들었습니다. Dan Abramov도 Hooks 등장 후에는 이 패턴을 예전만큼 권장하지 않는다고 언급했습니다 ([reactjs - Regarding Dan Abramov's update about Presentational and Container Components, and hooks - Stack Overflow](https://stackoverflow.com/questions/63506948/regarding-dan-abramovs-update-about-presentational-and-container-components-an#:~:text=But%20quite%20some%20time%20ago,that%20contain%20that%20code%20instead)). 상황에 따라 한 컴포넌트 내에서 UI와 로직이 적절히 혼합되는 편이 더 간결할 수 있습니다.
- **보일러플레이트 증가:** 컴포넌트를 둘로 쪼개면서 파일과 코드 구조가 늘어나 **초기 구현 비용**이 증가할 수 있습니다. 작은 컴포넌트까지 일률적으로 분리하면 오히려 복잡해질 수 있습니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=%EB%8B%A8%EC%A0%90)).

> **참고:** Hooks의 등장으로, 컨테이너 로직을 굳이 별도 컴포넌트로 만들기보다 **커스텀 Hook**으로 추출하는 방식이 대두되었습니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=Component%20)) ([Container/Presentational Pattern](https://www.patterns.dev/vue/container-presentational/#:~:text=However%2C%20with%20the%20emergence%20of,be%20helpful%20at%20certain%20times)). 아래 고급 구성 기법 섹션에서 Hooks 패턴을 다룹니다.

### 컴파운드 컴포넌트 패턴 (Compound Components)

**개요:** 컴파운드 컴포넌트 패턴은 **서로 밀접하게 연관된 하위 컴포넌트들을 하나의 부모 컴포넌트와 함께 구성**하는 패턴입니다. 여러 컴포넌트가 모여 하나의 유기적인 동작을 할 때 유용합니다. 대표적으로 **드롭다운**, **탭 메뉴**, **모달** 등이 있으며, 이러한 구성요소는 내부에 여러 하위 컴포넌트(`<Toggle>`, `<List>`, `<Tab>`, `<TabPanel>` 등)를 포함하고, 이들이 **공유 상태**를 통해 함께 동작합니다 ([Compound Pattern](https://www.patterns.dev/react/compound-pattern/#:~:text=In%20our%20application%2C%20we%20often,together%20to%20perform%20a%20task)) ([Compound Pattern](https://www.patterns.dev/react/compound-pattern/#:~:text=dependent%20on%20each%20other%20through,together%20to%20perform%20a%20task)). Compound 패턴에서는 부모 컴포넌트가 내부 상태와 로직을 관리하고, 자식 컴포넌트는 그 상태를 공유 받아 자신을 렌더링합니다.

**사용 사례:** **여러 부분으로 구성된 UI 요소**를 만들 때 사용합니다. 예를 들어 **탭(Tabs)** 컴포넌트를 구현한다고 하면, `<Tabs>` (부모) 내부에 `<Tabs.List>`와 `<Tabs.Panel>` 같은 자식들을 넣어 구조를 정의할 수 있습니다. 부모 `<Tabs>`는 현재 선택된 탭 인덱스 상태를 관리하고 Context 등을 통해 자식들에게 전달합니다. 사용자는 `<Tabs>` 컴포넌트 안에 원하는 구조의 `<Tabs.List>`와 `<Tabs.Panel>`을 JSX로 구성만 하면, 각각의 자식들이 부모 상태를 공유하여 알아서 동작하는 형태입니다. 아래는 간단한 **Dropdown (FlyOut)** 컴포넌트 예시입니다.

```tsx
// Compound Components Example: FlyOut (Dropdown menu)

// 1. Context 생성 및 부모 컴포넌트 정의
import { createContext, useState, useContext } from "react";
interface FlyOutState {
  open: boolean;
  toggle: () => void;
}
const FlyOutContext = createContext<FlyOutState | undefined>(undefined);

export function FlyOut({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState(false);
  // toggle 함수를 Context로 제공
  const toggle = () => setOpen((prev) => !prev);
  return (
    <FlyOutContext.Provider value={{ open, toggle }}>
      <div className="flyout">{children}</div>
    </FlyOutContext.Provider>
  );
}

// 2. Toggle 버튼 컴포넌트 정의 (드롭다운 열기/닫기)
export function Toggle({ children }: { children: React.ReactNode }) {
  const ctx = useContext(FlyOutContext);
  if (!ctx) throw new Error("Toggle must be used within a FlyOut");
  return (
    <button onClick={ctx.toggle}>
      {children || (ctx.open ? "Close Menu" : "Open Menu")}
    </button>
  );
}

// 3. List 컴포넌트 정의 (토글되는 목록)
export function List({ children }: { children: React.ReactNode }) {
  const ctx = useContext(FlyOutContext);
  if (!ctx) throw new Error("List must be used within a FlyOut");
  return ctx.open ? <ul className="menu-list">{children}</ul> : null;
}

// 사용 예시:
<FlyOut>
  <Toggle>메뉴 보기</Toggle>
  <List>
    <li>Item 1</li>
    <li>Item 2</li>
  </List>
</FlyOut>;
```

위 예시에서 `<FlyOut>` 컴포넌트는 내부 상태인 `open`과 `toggle` 함수를 Context를 통해 자식들에게 제공합니다. `<Toggle>`과 `<List>`는 이 Context를 받아와 드롭다운 열림 상태를 공유하므로, Toggle 버튼을 클릭하면 open 값이 바뀌고 그에 따라 List는 자신을 렌더링하거나 숨깁니다. 이처럼 **부모-자식 간에 암묵적인 연동**이 이루어져 사용자 입장에서는 선언적으로 `<FlyOut>` 내부에 원하는 구조의 JSX를 넣는 것만으로 컴포넌트들이 맞물려 동작합니다.

**언제 사용해야 하나:** 한 부모와 자식들이 **논리적으로 하나의 유닛**을 이루는 위젯들을 만들 때 사용합니다. 디자인 시스템이나 라이브러리 개발 시 자주 활용되며, 대표적으로 React-Bootstrap이나 Radix UI 같은 라이브러리의 컴포넌트들이 이 패턴을 따릅니다. **폼 그룹(Form with Field)**, **Accordion(아코디언)**, **Tabs**, **모달(Dialog)** 등이 Compound 패턴에 적합합니다. 부모 컴포넌트를 경계로 상태를 공유하므로 **props drilling 없이 자연스러운 조합**을 제공할 수 있습니다 ([Compound Pattern](https://www.patterns.dev/react/compound-pattern/#:~:text=In%20our%20application%2C%20we%20often,together%20to%20perform%20a%20task)) ([Compound Pattern](https://www.patterns.dev/react/compound-pattern/#:~:text=dependent%20on%20each%20other%20through,together%20to%20perform%20a%20task)).

**장점:**

- **유연한 인터페이스:** 사용자(개발자)가 JSX 트리 구조로 원하는 배치를 구성하면 컴포넌트들이 알아서 연동되므로, API가 직관적이고 **선언적**입니다.
- **상태 공유 용이:** Context 등을 통해 하위 컴포넌트들이 공통 상태를 쉽게 공유하여 **동기화**되므로, 별도의 상위 상태 관리 코드가 감소합니다 ([Compound Pattern](https://www.patterns.dev/react/compound-pattern/#:~:text=Using%20the%20Compound%20component%20pattern,is%20perfect%20for%20this%20example)) ([Compound Pattern](https://www.patterns.dev/react/compound-pattern/#:~:text=First%2C%20let%E2%80%99s%20create%20the%20,all%20the%20children%20it%20receives)).
- **캡슐화:** 관련된 컴포넌트들이 하나의 모듈로 뭉쳐져 있으므로 **응집도**가 높아지고, 외부에는 단일 컴포넌트처럼 보여 사용이 간단합니다.

**단점:**

- **구현 복잡성:** 내부적으로 Context, 상태관리, 적절한 타입 정의 등 구현 난이도가 높을 수 있습니다. 특히 compound 컴포넌트 간 계층 구조가 깊어지면 로직 추적이 어려울 수 있습니다.
- **오남용 시 어려운 디버깅:** 잘못된 구조로 컴포넌트를 중첩하거나 Context 제공 범위를 벗어나는 등 **사용 규약**을 어기면 런타임 오류가 발생할 수 있습니다 (예: `Context not found` 예외). 이에 대한 사용자 가이드를 명확히 해야 합니다.
- **성능:** 부모 Context 값이 변경되면 해당 Context를 소비하는 모든 자식이 재렌더링되므로, 큰 트리의 경우 성능에 유의해야 합니다. 필요하면 Context를 분리하거나 메모이제이션을 적용할 수 있습니다.

### 고차 컴포넌트 패턴 (Higher-Order Components, HOC)

**개요:** **Higher-Order Component(HOC)**는 *컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수*를 말합니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=A%20higher,emerges%20from%20React%E2%80%99s%20compositional%20nature)). React API의 일부는 아니지만, React의 합성 특성에서 자연스럽게 등장한 패턴입니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=A%20higher,emerges%20from%20React%E2%80%99s%20compositional%20nature)). 주로 **공통 로직을 여러 컴포넌트에 주입**하거나 **크로스컷팅 관심사(여러 곳에서 공통적으로 필요한 기능)**를 처리할 때 사용됩니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=HOCs%20are%20common%20in%20third,Redux%E2%80%99s%20connect%20and%20Relay%E2%80%99s%20createFragmentContainer)) ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=Use%20HOCs%20For%20Cross)). 예를 들어, Redux의 `connect` 함수나 React Router v5의 HOC(`withRouter`) 등이 HOC 패턴의 대표적인 활용입니다.

**사용 사례:** **인증**(Authentication)이나 **권한 제어**, **로깅**, **에러 처리** 등 여러 UI 컴포넌트에서 공통적으로 적용해야 하는 기능을 HOC로 만들 수 있습니다 ([How to Use Higher-Order Components in React - freeCodeCamp](https://www.freecodecamp.org/news/higher-order-components-in-react/#:~:text=freeCodeCamp%20www.freecodecamp.org%20%20Higher,authentication%2C%20error%20handling%2C%20logging%2C)). 예를 들어, 페이지 컴포넌트에 접속하기 전에 로그인 여부를 검사해서 미인증 시 로그인 페이지로 리다이렉트하는 `withAuth` HOC를 정의할 수 있습니다. 또는, 특정 컴포넌트에 prop을 자동으로 주입하는 HOC (예: `withTheme`으로 `theme` prop 제공)를 구현할 수 있습니다. 아래는 간단한 `withAuth` HOC 예시입니다.

```tsx
// withAuth.tsx – 컴포넌트를 감싸 인증 기능을 추가하는 HOC
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

function withAuth<P>(WrappedComponent: React.ComponentType<P>) {
  // 익명 함수형 컴포넌트 반환
  return function AuthenticatedComponent(props: P) {
    const router = useRouter();
    const isLoggedIn = /* 사용자 인증 상태 확인 */;
    useEffect(() => {
      if (!isLoggedIn) {
        router.replace('/login'); // 로그인 페이지로 리다이렉트
      }
    }, [isLoggedIn]);

    if (!isLoggedIn) {
      return null; // 리다이렉트 전까지 아무 것도 렌더링하지 않음
    }
    // 인증된 경우 원래 컴포넌트 렌더링
    return <WrappedComponent {...props} />;
  };
}

export default withAuth;
```

사용 시 `export default withAuth(MyPageComponent)`처럼 내보내면, `MyPageComponent`는 인증이 필요한 컴포넌트로 동작합니다. 이처럼 HOC는 **원래 컴포넌트를 감싸는 래퍼**로서 동작하며, 공통 기능을 부여하거나 props를 가공하여 전달합니다.

**언제 사용해야 하나:** 여러 컴포넌트에 걸쳐 반복되는 로직을 한 곳에서 관리하고 싶을 때 HOC를 고려할 수 있습니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=HOCs%20are%20common%20in%20third,Redux%E2%80%99s%20connect%20and%20Relay%E2%80%99s%20createFragmentContainer)). Redux 사용 시 `connect`, Formik의 `withFormik` 등 **서드파티 라이브러리**에서도 종종 사용되었습니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=HOCs%20are%20common%20in%20third,Redux%E2%80%99s%20connect%20and%20Relay%E2%80%99s%20createFragmentContainer)). 다만 현대 React에서는 HOC의 사용 빈도가 많이 줄었는데, 그 이유는 **Hooks**로 대부분의 공통 로직 공유가 가능해졌기 때문입니다. 따라서 새로운 코드를 작성할 때 HOC는 특별한 이유가 없다면 지양하고, **대체 패턴**(예: 커스텀 Hook, Render Props)을 먼저 고려하는 것이 일반적입니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=,used%20in%20modern%20React%20code)) ([Render Props – React](https://legacy.reactjs.org/docs/render-props.html#:~:text=the%20new%20React%20docs.%20,been%20replaced%20by%20custom%20Hooks)).

**장점:**

- **로직 재사용**: 한 번 구현한 공통 기능(HOC 함수)을 여러 컴포넌트에 쉽게 적용 가능하여 **중복 코드 감소** 및 **일관성**을 유지합니다.
- **관심사 분리**: 개별 컴포넌트는 자기 고유의 UI/로직에 집중하고, 부가적인 공통 기능은 HOC에 위임하여 **코드가 깔끔**해집니다. 예를 들어 UI 컴포넌트는 인증 여부를 몰라도 되고, HOC가 인증 로직을 책임집니다.
- **캡슐화**: HOC 내부에 공통 로직이 숨겨져 있으므로, 적용받는 컴포넌트 입장에서는 그저 props를 받는 것처럼 동작합니다. 외부에서는 HOC 적용 유무만으로 컴포넌트 기능을 바꿀 수 있어 **데코레이터**처럼 활용 가능합니다.

**단점:**

- **디버깅 어려움**: 컴포넌트 트리가 HOC로 감싸져 깊어지므로 React DevTools에서 구조가 복잡하게 보일 수 있고, 스택 트레이스도 HOC를 거쳐가기 때문에 직접적인 원인 파악이 어려워질 수 있습니다.
- **props 충돌 가능성**: HOC가 원본 컴포넌트에 props를 전달하거나 추가할 때, 혹시 원본이 같은 이름의 prop을 사용할 경우 **충돌** 위험이 있습니다. 네이밍에 주의해야 하고, HOC를 설계할 때 props를 명시적으로 관리해야 합니다.
- **점진적 폐기 추세**: 공식 문서에서도 "HOC는 modern React에서는 흔하지 않다"고 명시하고 있습니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=,used%20in%20modern%20React%20code)). Hooks로 대체 가능하며, TypeScript 환경에서 HOC의 제네릭 타입 다루기도 까다롭습니다. 따라서 새로운 패턴에 비해 **선호도가 낮아지는 추세**입니다.

> **참고:** React 18 기준 공식 문서에서는 *"Higher-order components are not commonly used in modern React code."*라고 언급하고 있습니다 ([Higher-Order Components – React](https://legacy.reactjs.org/docs/higher-order-components.html#:~:text=,used%20in%20modern%20React%20code)). 가능하면 HOC 대신 **커스텀 Hook 패턴**을 사용하도록 권장합니다 (다음 섹션 참고).

### 렌더 프롭 패턴 (Render Props)

**개요:** **Render Props** 패턴은 컴포넌트의 children이나 prop으로 **함수**를 전달하여, 그 함수를 통해 원하는 UI를 그리는 패턴입니다. 즉, *"컴포넌트의 '무엇을 렌더링할지'를 함수 형태의 prop으로 넘겨서 결정하는 기술"*을 가리킵니다 ([Render Props – React](https://legacy.reactjs.org/docs/render-props.html#:~:text=The%20term%20%E2%80%9Crender%20prop%E2%80%9D%20refers,whose%20value%20is%20a%20function)). 이를 통해 상태나 로직을 공유하는 공용 컴포넌트가 있고, 구체적인 렌더링 내용은 호출 측에서 함수로 주입하여 **커스터마이징**할 수 있습니다. 예를 들어, React Router v5의 `<Route>` 컴포넌트는 `component` prop 대신 **render prop**을 사용하는 방식으로 필요한 UI를 그렸습니다. 또한 Downshift(자동완성 라이브러리), Formik(폼 라이브러리) 등이 render props를 활용했습니다 ([Render Props – React](https://legacy.reactjs.org/docs/render-props.html#:~:text=Libraries%20that%20use%20render%20props,React%20Router%2C%20Downshift%20and%20Formik)).

**사용 사례:** **반복되는 로직을 공유하되, UI 표현은 각기 다르게 해야 할 때** render prop을 사용합니다. 예를 들어, **마우스 좌표 추적 컴포넌트**를 만들어서 현재 마우스 위치를 children 함수로 넘겨주면, 그 값을 이용해 다른 UI를 그리는 여러 컴포넌트를 만들 수 있습니다. 아래는 마우스 좌표를 추적하는 `MouseTracker` 컴포넌트 예시입니다.

```tsx
// MouseTracker.tsx - 마우스 위치 추적 컴포넌트
import { useState, useEffect } from "react";

type MouseProps = {
  children: (pos: { x: number; y: number }) => JSX.Element;
};
export function MouseTracker({ children }: MouseProps) {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  useEffect(() => {
    const update = (e: MouseEvent) => setPos({ x: e.clientX, y: e.clientY });
    window.addEventListener("mousemove", update);
    return () => window.removeEventListener("mousemove", update);
  }, []);
  return children(pos); // children으로 받은 함수를 호출하여 JSX 반환
}

// 사용 예시:
<MouseTracker>
  {({ x, y }) => (
    <p>
      현재 좌표: ({x}, {y})
    </p> // 원하는 UI로 표현
  )}
</MouseTracker>;
```

위 코드에서 `MouseTracker`는 내부적으로 마우스 좌표 상태를 관리하고, `children`으로 전달된 함수를 호출하면서 현재 좌표를 인자로 넘겨줍니다. 사용자는 JSX에서 `<MouseTracker>{pos => /* ... */}</MouseTracker>` 형태로 **함수 child**를 제공하고, 그 함수 내부에서 (x, y)를 활용한 원하는 UI를 반환합니다. 이를 통해 다양한 컴포넌트가 `MouseTracker`의 기능을 공유하면서도 각기 다른 표현을 할 수 있습니다.

**언제 사용해야 하나:** 컴포넌트로 **공통 기능(상태 관리나 계산 등)**을 제공하고, 그 결과를 기반으로 하는 UI 표현을 유연하게 변경해야 할 때 사용합니다. 예를 들어 위의 마우스 추적, 윈도우 사이즈 리스닝, 스크롤 위치 감시, 또는 **데이터 페칭 공통 컴포넌트** 등을 만들고, render prop으로 children을 받아 각 상황별 UI를 그리게 할 수 있습니다. Render Props는 HOC와 유사한 문제를 풀지만, JSX 트리 안에서 해결한다는 점이 다릅니다. 특히 **TypeScript**로 HOC를 사용하는 것이 번거롭다면, render prop 패턴이 대안이 될 수 있습니다(함수 시그니처만 정의하면 되므로 제네릭 인자 문제가 적음).

**장점:**

- **높은 유연성:** 로직을 담은 컴포넌트 하나로 다양한 UI 시나리오를 소화할 수 있습니다. 렌더링 부분을 함수로 외부에서 주입받으므로 **사용자가 UI를 제어**할 수 있습니다 ([Render Props – React](https://legacy.reactjs.org/docs/render-props.html#:~:text=The%20term%20%E2%80%9Crender%20prop%E2%80%9D%20refers,whose%20value%20is%20a%20function)).
- **명시적 데이터 전달:** 필요한 데이터나 상태를 함수 인자로 넘기므로 prop 이름 충돌 없이 명확히 값을 주고받습니다.
- **Hooks 이전의 재사용 패턴:** Hooks 도입 전에는 HOC보다 **render prop이 더 선언적**이라 선호되기도 했습니다. 가독성이 좋고 디버깅 시에도 UI 트리에 드러나 HOC보다 추적이 수월한 면이 있습니다.

**단점:**

- **JSX 중첩**: 여러 단계의 render prop을 남용하면 `<A>{a => <B>{b => <C>{c => ...}</C>}</B>}</A>` 처럼 코드가 중첩되어 읽기 어려워지는 **Wrapper Hell**이 생길 수 있습니다.
- **매번 새로운 함수 생성:** render prop에 함수를 직접 정의하여 넘기면, 렌더링마다 새로운 함수 객체가 생성되므로 PureComponent나 `React.memo`에는 매 렌더 다른 props로 인식됩니다. 이로 인해 불필요한 재렌더가 발생할 수 있습니다. (필요하다면 useCallback으로 메모이제이션 가능)
- **일부 성능 부담:** 상기 이유로, 너무 빈번히 업데이트 되는 상황에서는 HOC보다 불리할 수 있습니다. 그러나 일반적으로 큰 문제가 되진 않으며, React 18부터는 자동 배치와 concurrency로 여유있게 처리되는 편입니다.

> **참고:** 공식 문서에 따르면 **많은 경우 Render Props 패턴은 커스텀 Hook으로 대체**할 수 있다고 명시하고 있습니다 ([Render Props – React](https://legacy.reactjs.org/docs/render-props.html#:~:text=the%20new%20React%20docs.%20,been%20replaced%20by%20custom%20Hooks)). 실제로 React Router, Formik 등도 Hooks를 제공하면서 render prop API 사용을 줄였습니다. 새로운 코드에서는 가능하다면 **Hooks 패턴**을 사용하세요.

### Atomic 디자인 패턴 (Atomic Design)

**개요:** Atomic Design은 2013년 Brad Frost가 제안한 **디자인 시스템 컴포넌트 구성 방식**입니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=Atomic%20Design%20Pattern)). 원래 UI 디자인 시스템에서 나온 개념이지만, React 컴포넌트 구조에도 적용됩니다. **원자(Atom)**, **분자(Molecule)**, **유기체(Organism)**, **템플릿(Template)**, **페이지(Page)**의 5단계로 컴포넌트 계층을 구분합니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=Atomic%20Design%20Pattern)). 가장 작은 단위의 컴포넌트를 Atom으로 만들고, 이것들을 조합하여 상위 단계 컴포넌트를 구성해나가는 **계층적 조합** 패턴입니다.

**사용 사례:** **디자인 시스템 구축**이나 **컴포넌트 라이브러리** 개발 시 유용합니다. 예를 들어 Atomic 디자인을 적용하면, 버튼, 인풋 등 기본 요소를 Atom으로 만들고, Atom들을 조합하여 Form(Field + Label 등) 같은 Molecule을 만들며, 더 복잡한 헤더나 푸터 같은 Organism을 구성합니다. 이렇게 하면 **폴더 구조와 컴포넌트 관계가 체계적**으로 잡히고, 재사용성이 극대화됩니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=%EC%9E%A5%EC%A0%90)) ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=,%EC%8A%A4%ED%83%80%EC%9D%BC%20%EA%B0%80%EC%9D%B4%EB%93%9C%20%EB%8F%84%EA%B5%AC%20%EC%82%AC%EC%9A%A9%EC%9D%B4%20%EC%9A%A9%EC%9D%B4)). Next.js 프로젝트라면 `components/atom`, `components/molecule` 등의 폴더로 구분하여 관리할 수도 있습니다.

**언제 사용해야 하나:** **여러 프로젝트에서 일관된 UI**를 유지해야 하거나, **크고 복잡한 앱을 체계적으로 관리**해야 할 때 적합합니다. Atomic 패턴을 따르면 작은 컴포넌트부터 큰 화면까지 구성 관계가 명확해지므로, **디자인 가이드 준수**나 **컴포넌트 카탈로그 작성**에 유리합니다. 팀 단위로 컴포넌트를 재사용하거나, Storybook 등의 도구와 함께 디자인 시스템을 운영할 때 좋은 기반이 됩니다.

**장점:**

- **높은 재사용성:** 컴포넌트를 기능/규모 단위로 쪼개 두므로 **UI 재사용**이 극대화됩니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=%EC%9E%A5%EC%A0%90)).
- **체계적인 구조:** 계층별 폴더/네이밍 규칙으로 관리하므로 프로젝트 구조가 일관되고 **예측 가능**합니다. 새로운 기여자도 구조를 이해하기 쉽습니다.
- **디자인-개발 연계:** 디자인 시스템과 용어가 통일되어 **디자이너와 개발자 간 소통**이 원활해지고, 디자인 가이드에 따라 컴포넌트를 만들기 쉽습니다.

**단점:**

- **초기 구축 비용:** 처음 Atomic 구조를 세우고 어디까지를 어떤 단위로 볼지 결정하는 데 시간과 토론이 필요합니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=%EB%8B%A8%EC%A0%90)). 작은 프로젝트에는 과할 수 있습니다.
- **경계 모호성:** 어느 수준을 Atom으로 볼지 등 **카테고리화가 애매**한 경우가 생길 수 있습니다. 팀 내 합의를 통한 기준 수립이 필요합니다.
- **추상화 남용 위험:** 지나치게 세분화하면 파일과 컴포넌트가 너무 많아지고, 오히려 개발이 번거로워질 수 있습니다. 적절한 균형이 중요합니다.

## 상태 관리 및 데이터 흐름 (State Management & Data Flow)

React는 **단방향 데이터 흐름(one-way data flow)**을 기본 원칙으로 합니다. 상위 컴포넌트에서 하위 컴포넌트로 props를 통해 데이터가 흐르고, 하위에서 상위로 이벤트를 통해 상향 통신하는 구조입니다. 이러한 흐름 속에서 상태를 어디에 보관하고, 어떻게 공유하며, 외부 데이터는 어떻게 가져올지 등의 문제가 발생합니다. 이 섹션에서는 **상태 관리와 데이터 전달**과 관련된 주요 패턴을 다룹니다.

### 상태 끌어올리기 (Lifting State Up)

**개요:** **Lifting State Up(상태 끌어올리기)**는 두 컴포넌트가 동일한 상태 정보를 필요로 할 때, 그 상태를 공통 조상 컴포넌트로 올려서 한 곳에서 관리하고 하위로 내려보내는 패턴입니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=Sometimes%2C%20you%20want%20the%20state,will%20do%20writing%20React%20code)). React 공식 문서에서도 "리액트를 쓰며 **가장 자주** 하게 될 일"로 이 상태 끌어올리기를 꼽을 정도로 기본적인 패턴입니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=Sometimes%2C%20you%20want%20the%20state,will%20do%20writing%20React%20code)). 핵심은 **공유해야 하는 state의 단일 소스**를 만들고, props를 통해 필요한 곳에 전달함으로써 데이터 일관성을 유지하는 것입니다.

**사용 사례:** 형제 컴포넌트나 멀리 떨어진 컴포넌트들이 **같은 상태를 참조하거나 변경**해야 할 때 사용합니다. 예를 들어, 두 텍스트 입력 필드의 값이 서로 연관되어 유효성 검사를 공유해야 한다면, 값과 검증 상태를 부모로 끌어올려 관리하고 자식 입력 필드는 props로 값과 onChange를 받아 사용하게 합니다. 또 다른 예로, Accordion의 여러 Panel 중 하나만 열리도록 하기 위해 각 Panel의 open 여부 상태를 부모 Accordion으로 올려 관리하는 경우가 있습니다.

```tsx
// 간단한 예: 두 입력 필드의 값을 공유 (리프팅 전 vs 후)

// Before: 상태가 각자 관리되어 서로 모름
function Input1() {
  const [text, setText] = useState("");
  return <input value={text} onChange={(e) => setText(e.target.value)} />;
}
function Input2() {
  const [text, setText] = useState("");
  return <input value={text} onChange={(e) => setText(e.target.value)} />;
}

// After: 상태를 부모로 끌어올림
function ParentInputs() {
  const [text, setText] = useState("");
  return (
    <>
      <Input value={text} onChange={setText} />
      <DisplayLength text={text} />
    </>
  );
}
function Input({
  value,
  onChange,
}: {
  value: string;
  onChange: (v: string) => void;
}) {
  return <input value={value} onChange={(e) => onChange(e.target.value)} />;
}
function DisplayLength({ text }: { text: string }) {
  return <p>글자 수: {text.length}</p>;
}
```

위의 After 구조에서 `ParentInputs`가 상태 `text`를 관리하고, 두 자식 (`Input`, `DisplayLength`)에게 props로 내려줍니다. 그 결과 Input 컴포넌트에서 텍스트를 변경하면 `ParentInputs`의 상태가 업데이트되고, DisplayLength도 같은 `text`를 props로 받아 표시를 갱신합니다. 이렇게 하면 두 하위 컴포넌트가 **항상 동일한 데이터에 기반**하여 동작하게 됩니다.

**언제 사용해야 하나:** 두 곳 이상에서 필요한 상태라면 우선 **가까운 공통 조상으로 상태를 올리는 것**을 고려하세요. React 앱을 만들다 보면 가장 자연스러운 흐름입니다. 작은 애플리케이션에선 굳이 글로벌 상태 관리 라이브러리(Redux 등)를 도입하지 않아도, 이 패턴의 연속으로 대부분의 공유 상태 문제를 해결할 수 있습니다. 또한, 상태 끌어올리기는 **컨트롤드 컴포넌트 구현**과도 연결되는데, 부모가 상태를 들고 자식에게 prop으로 값을 주고 변경 콜백을 전달하면 자식은 **Controlled Component(제어 컴포넌트)**가 됩니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=In%20contrast%2C%20you%20might%20say,component)).

**장점:**

- **한 곳에서 진실 관리:** 상태를 하나로 모으므로 **데이터 일관성**이 유지됩니다. 여러 컴포넌트가 같은 데이터를 각자 관리하지 않게 되어 버그를 줄입니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=Sometimes%2C%20you%20want%20the%20state,will%20do%20writing%20React%20code)).
- **간단한 구현:** React의 기본 메커니즘(props 전달)만으로 구현 가능하므로 추가 러닝커브나 라이브러리 없이 쉽게 적용할 수 있습니다.
- **예측 가능한 흐름:** 데이터가 부모→자식 방향으로 흐르고, 변경은 부모에서 일어나므로 애플리케이션 상태 흐름이 **명확**해집니다.

**단점:**

- **Prop drilling 발생:** 상태를 매우 높은 상위로 끌어올린 경우, 실제로 필요없는 중간 컴포넌트들이 그 상태를 전달하기만 위해 props를 물려줘야 할 수 있습니다. 이로 인해 많은 컴포넌트에 걸쳐 동일한 prop이 전달되는 **verbosity**가 생길 수 있습니다 (이 문제는 Context API로 일부 완화 가능).
- **부모 컴포넌트 복잡도 증가:** 상태를 몰아 관리하면 부모 컴포넌트의 코드가 복잡해질 수 있습니다. 너무 많은 상태를 한 컴포넌트에서 관리하면 유지보수가 어려워지므로, 적절히 분리하는 센스가 필요합니다.
- **모든 경우에 적합하지는 않음:** 컴포넌트 간 공유가 아닌 전역적 개념의 상태(예: 다크 모드, 로그인 정보)는 컨텍스트나 전역 상태 라이브러리가 더 나을 수 있습니다. 상황에 따라 적절한 수단을 선택해야 합니다.

### 컨트롤드 vs 언컨트롤드 컴포넌트 (Controlled vs Uncontrolled Components)

**개요:** **Controlled Component(제어 컴포넌트)**와 **Uncontrolled Component(비제어 컴포넌트)**는 주로 **폼 입력 요소**의 상태 관리 방식에 대한 패턴입니다. React에서 **Controlled 컴포넌트**란 중요한 데이터가 **props로 제어되는 컴포넌트**를 말합니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=In%20contrast%2C%20you%20might%20say,component)). 반대로 **Uncontrolled 컴포넌트**는 **내부 로컬 state로 자체 관리**되는 컴포넌트입니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=It%20is%20common%20to%20call,panel%20is%20active%20or%20not)). 예를 들어 `<input>` 입력 필드에 `value`와 `onChange`를 모두 지정하면 그 값은 React state에 의해 완전히 통제되므로 Controlled입니다. 아무 제어 없이 `<input defaultValue="..." />`처럼 쓰고 나중에 `ref`로 값을 읽는다면 Uncontrolled입니다.

**사용 사례:** 폼 입력이나 UI 요소를 다룰 때 **어떨 때 state를 React에서 가질지** 결정해야 합니다. Controlled를 사용하면 모든 변화가 React state를 통해 이루어지므로 **실시간 검증**, **동적 폼 제어**, **입력에 따른 다른 UI 업데이트** 등이 가능해집니다. 예를 들어, **검색 필터 입력**을 Controlled로 관리하면 입력 값이 바뀔 때마다 리스트를 필터링하는 로직을 바로 수행할 수 있습니다. 반면, **파일 입력 `<input type="file">`** 같은 요소는 굳이 state로 관리하지 않고 폼 제출 시 `ref.current.files`로 읽는 Uncontrolled로 쓰기도 합니다. 또한 **단순한 폼**에서는 Uncontrolled로 두고 최종적으로 한 번에 값을 모아 처리하는 방식도 간혹 사용됩니다 (예: React Hook Form 라이브러리는 내부적으로 Uncontrolled 방식으로 DOM 값을 관리).

```tsx
// Controlled vs Uncontrolled input example

// Controlled input
function ControlledInput() {
  const [value, setValue] = useState("");
  return (
    <input
      value={value}
      onChange={(e) => setValue(e.target.value)}
      placeholder="Controlled"
    />
  );
}

// Uncontrolled input
function UncontrolledInput() {
  const inputRef = useRef<HTMLInputElement>(null);
  const showValue = () => {
    alert(`Uncontrolled Value: ${inputRef.current?.value}`);
  };
  return (
    <>
      <input defaultValue="Hello" ref={inputRef} placeholder="Uncontrolled" />
      <button onClick={showValue}>Show Value</button>
    </>
  );
}
```

위에서 `ControlledInput`은 `value`를 state로 갖고 있어 사용자가 타이핑 할 때마다 `onChange`로 state를 업데이트합니다. 항상 `value` prop이 지정되어 있으므로 DOM의 값은 React state의 **단일 진실 소스**에 의해 통제됩니다. `UncontrolledInput`은 initial value만 `defaultValue`로 주고 이후에는 React가 간섭하지 않습니다. 필요시 `ref.current.value`를 통해서만 값을 얻습니다.

**언제 사용해야 하나:** 일반적으로 **대부분의 경우 Controlled를 권장**합니다. Controlled 컴포넌트는 부모나 전역 상태가 값을 완전히 통제하므로, 변화에 따른 즉각적인 논리 처리가 가능하며, React의 선언적 사이클과도 맞아떨어집니다. 특히 **양방향 바인딩 대신 단방향 데이터 흐름**을 유지하면서도 사용자 입력을 다룰 수 있다는 점이 Controlled 패턴의 큰 장점입니다. 다만, 간단한 폼에서 입력 후 **한 번에 처리**하고자 할 때나, React 외부에서 제어되는 UI (예: 제3자 UI 위젯)와 연계할 때는 Uncontrolled를 사용할 수 있습니다. **파일 선택 필드**나 **텍스트 영역에서 매우 긴 입력**(Controlled로 하면 타이핑마다 re-render) 등은 상황에 따라 Uncontrolled가 편할 수 있습니다.

**장점 (Controlled):**

- **예측 가능한 상태**: 모든 입력값이 React state로 관리되므로, 애플리케이션 상태와 UI가 항상 일치합니다. 부모 컴포넌트가 props로 값을 주도하므로 컴포넌트의 동작을 완전히 파악할 수 있습니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=In%20contrast%2C%20you%20might%20say,component)).
- **즉각적인 유효성 검사 및 동기화**: 입력 변화에 따라 바로 다른 컴포넌트 업데이트, 폼 검증, 버튼 활성화/비활성 등의 **비즈니스 로직을 즉시 적용**하기 쉽습니다.
- **단방향 데이터 흐름 유지**: React 철학에 맞게 데이터가 상위 -> 하위로 흐르므로 디버깅이 쉽고, state 소스를 한 곳에서 관리하므로 유지보수성이 높습니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=Uncontrolled%20components%20are%20easier%20to,fully%20configure%20them%20with%20props)).

**단점 (Controlled):**

- **타이핑 성능 부담**: 많은 양의 입력을 가진 폼 (특히 입력이 여러 개이거나 실시간으로 길게 입력하는 경우)에서 매 글자마다 re-render와 state 업데이트가 일어나 성능에 영향 줄 수 있습니다. (그러나 대부분 적절한 최적화로 상쇄 가능)
- **코드량 증가**: 각 입력마다 state와 onChange 핸들러를 작성해야 하므로 boilerplate 코드가 늘어납니다. 작은 폼이라도 Controlled로 하면 초기 코드 작성이 다소 번거로울 수 있습니다.
- **외부 제어 어려움**: DOM API를 직접 써야 하는 특수한 경우 (예: 파일 업로드, 제3자 위젯 연동)은 Controlled에서는 모든 것을 state로 표현하기 어려워 종종 ref를 함께 써야 합니다.

**장점 (Uncontrolled):**

- **구현 간단**: 초기 값만 정해주면 이후 별도 관리가 필요 없으므로, **폼을 빠르게 구성**하는 데 편합니다. React Hook Form 같은 라이브러리는 이 방식을 활용해 성능과 간결함을 얻습니다.
- **낮은 오버헤드**: 입력 변화에 React가 관여하지 않으므로, 매우 민감한 입력 이벤트 처리에 약간 더 유리할 수 있습니다. (다만 일반적인 상황에서는 큰 차이 없음)

**단점 (Uncontrolled):**

- **제한된 상호작용**: 부모 컴포넌트가 즉각적으로 그 값을 알 방법이 없어서, 입력값에 기반한 다른 UI 업데이트나 검증을 **실시간으로 하기 어렵습니다** ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=Uncontrolled%20components%20are%20easier%20to,fully%20configure%20them%20with%20props)).
- **상태 소스 분산**: 중요한 정보가 DOM에 숨어 있게 되므로, React state와 동기화가 어긋날 수 있고, 애플리케이션 상태 파악이 힘들어집니다. 특히 컴포넌트가 언마운트되면 그 값은 잃게 되므로, 필요 시 별도로 값 수집 로직이 필요합니다.
- **테스트 어려움**: 값을 가져오려면 DOM에 접근해야 하므로, React 컴포넌트의 단위 테스트에서는 Controlled보다 Uncontrolled가 다루기 까다롭습니다.

**요약:** 폼 입력 등 대부분의 경우 **Controlled 컴포넌트**를 사용하여 React state로 관리하는 것이 권장됩니다 ([Sharing State Between Components – React](https://react.dev/learn/sharing-state-between-components#:~:text=When%20writing%20a%20component%2C%20consider,your%20mind%20and%20refactor%20later)). Uncontrolled는 특수한 상황에서 보완적으로 사용하세요.

### 컨텍스트 & Provider 패턴 (Context API)

**개요:** **Context API**는 React에서 **컴포넌트 트리를 통해 전역적으로 데이터**를 전달할 때 사용하는 내장 기능입니다. `React.createContext()`로 Context를 만들고, 상위에서 `<MyContext.Provider value={...}>`로 값을 제공하면, 하위 어디서든 `useContext(MyContext)`로 그 값을 꺼내 쓸 수 있습니다. 이 패턴을 활용하면 중간 단계의 컴포넌트들에게 일일이 props로 전달할 필요 없이 **필요한 곳에서 직접 데이터에 접근**할 수 있게 됩니다 ([Passing Data Deeply with Context – React](https://react.dev/learn/passing-data-deeply-with-context#:~:text=Usually%2C%20you%20will%20pass%20information,tree%20below%20it%E2%80%94no%20matter%20how)). 흔히 **Provider 패턴**이라고 부르며, Redux 등의 외부 상태도 최상위에서 `<Provider>`를 써서 Context를 통해 하위에 주입합니다.

**사용 사례:** **전역 상태**나 **테마, 언어 설정, 인증 정보** 등 애플리케이션 전반에 걸쳐 필요한 데이터를 공급할 때 사용합니다. 예를 들어 **ThemeContext**를 만들어 `<ThemeProvider value={theme}>`로 앱을 감싸면, 깊은 하위에 있는 어떤 버튼 컴포넌트도 `useContext(ThemeContext)`로 현재 테마를 알 수 있습니다. 또한 앞서 언급한 **Compound 컴포넌트 패턴**도 부모-자식 간 상태 공유에 Context를 이용하며, **다크모드 토글**, **로그인 사용자 정보** 등도 Context로 관리하기 적합합니다 ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=,applications%20with%20limited%20state%20complexity)). Next.js 13 App Router에서는 `layout.tsx`에서 Providers를 정의해 애플리케이션 전역 상태(예: 테마, i18n) Context를 공급하는 것이 일반적입니다.

```tsx
// ThemeContext.tsx - 테마 컨텍스트 예제
import { createContext, useContext, useState, ReactNode } from "react";

type Theme = "light" | "dark";
const ThemeContext = createContext<
  | {
      theme: Theme;
      toggleTheme: () => void;
    }
  | undefined
>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>("light");
  const toggleTheme = () =>
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 하위 컴포넌트 아무 곳에서나 사용
function ThemeToggleButton() {
  const ctx = useContext(ThemeContext);
  if (!ctx)
    throw new Error("ThemeToggleButton must be used within ThemeProvider");
  return <button onClick={ctx.toggleTheme}>현재 테마: {ctx.theme}</button>;
}
```

위 코드에서 `ThemeProvider`는 `theme` 상태와 `toggleTheme` 함수를 Context value로 제공하고 있습니다. 어느 컴포넌트든 `ThemeContext`를 useContext로 사용하면 현재 theme와 toggle 함수를 얻어 쓸 수 있습니다.

**언제 사용해야 하나:** **Prop drilling**이 심할 때나, 애플리케이션의 **글로벌한 크로스컷팅 상태**를 관리할 때 사용합니다 ([Passing Data Deeply with Context – React](https://react.dev/learn/passing-data-deeply-with-context#:~:text=Usually%2C%20you%20will%20pass%20information,tree%20below%20it%E2%80%94no%20matter%20how)). 예를 들어 다수의 컴포넌트가 공유해야 하는 설정, 로그인 정보, 현재 선택된 상품 등의 데이터를 상위에서 하위로 계속 전달하는 대신 Context로 한 번 제공하면 편리합니다. 또한 **여러 개의 서로 다른 컨텍스트**를 사용해 관심사별 전역 상태를 분리할 수도 있습니다 (예: AuthContext, ThemeContext 따로). Next.js 환경에서는 서버 컴포넌트에서는 Context를 사용할 수 없지만, **클라이언트 컴포넌트 영역**에서 주로 Provider를 활용합니다. 페이지 전환 간에도 유지되어야 하는 값은 `_app.tsx` (Next 12 이하)나 layout에서 Provider로 씌우면 편합니다.

**장점:**

- **Prop Drilling 해소:** 중간 구성요소를 거치지 않고 필요한 곳에 바로 접근하므로, 많은 단계의 props 전달이 없어져 **코드가 간결**해집니다 ([Passing Data Deeply with Context – React](https://react.dev/learn/passing-data-deeply-with-context#:~:text=Usually%2C%20you%20will%20pass%20information,tree%20below%20it%E2%80%94no%20matter%20how)).
- **전역 상태 공유 용이:** 리덕스 없이도 간단한 전역 상태 관리를 할 수 있습니다. 별도 라이브러리 부담 없이 내장 기능으로 **글로벌 스토어** 역할을 일부 수행합니다.
- **컴포넌트 트리 분리:** Context를 경계로 **독립적인 하위 트리**를 구성해, 서로 다른 컨텍스트 값으로 앱 일부만 다르게 동작시키는 것도 가능합니다 (Provider를 중첩하면 됨).

**단점:**

- **남용 시 복잡성:** 너무 많은 종류의 Context를 만들거나, 너무 광범위한 데이터를 Context에 넣으면 오히려 구조 파악이 어려워집니다. Context는 주로 **정적인 정보 or 드물게 바뀌는 상태**에 알맞습니다. 빈번히 변하는 state를 Context로 두면 하위 많은 컴포넌트들이 불필요하게 재렌더되어 **성능 저하**가 생길 수 있습니다.
- **디버깅 어려움:** props와 달리 Component 트리에 드러나지 않고 숨겨진 통로로 전달되므로, 어떤 값이 어디서 오는지 한눈에 파악하기 어려울 수 있습니다. DevTools로는 추적이 안 되니 개발자가 구조를 기억해야 합니다.
- **테스트 복잡성:** Context를 사용하는 컴포넌트를 테스트하려면 Provider로 감싸야 하는 등 약간의 준비가 필요합니다. 하지만 Test Utils에서 Provider를 쉽게 넣을 수 있으므로 큰 문제는 아닙니다.

### 전역 상태 관리 (Flux / Redux 패턴 등)

**개요:** 앱 규모가 커지면 상태 끌어올리기와 Context만으로 관리가 벅찰 수 있습니다. **Flux 아키텍처**는 Facebook이 제안한 단방향 데이터 흐름 아키텍처로, 그 구현 중 가장 유명한 것이 **Redux**입니다. Redux는 **전역 스토어(store)** 한 곳에 애플리케이션 상태를 모두 모으고, **액션(action)**을 통해서만 상태를 변경하며, **리듀서(reducer)** 함수로 변경 로직을 순수 함수로 정의하는 패턴입니다. 이를 통해 상태 변경을 예측 가능하게 하고, 어느 컴포넌트에서나 store를 구독하여 필요한 데이터를 얻도록 합니다. Redux 외에도 MobX, Flux, Context+useReducer 조합, 그리고 최근의 경량 상태관리 라이브러리들(Zustand, Jotai 등)이 모두 전역 상태 관리 패턴에 속합니다.

**사용 사례:** **애플리케이션 규모가 클 때** 또는 **컴포넌트 간 상태 공유가 매우 빈번하고 복잡할 때** 전역 상태 관리 도구를 도입합니다. 예를 들어, 전 전역에서 접근해야 하는 **사용자 인증 정보**, 여러 페이지에 걸쳐 공유되는 **캐싱된 데이터**, 또는 **여러 종류의 상태가 복잡하게 얽힌 대규모 앱**(예: 프로젝트 관리 도구의 상태)에서는 Redux와 같은 체계를 쓰면 효과적입니다. 또한 **시간 여행 디버깅**이나 **상태 변화 로깅**이 필요할 때도 Redux를 활용합니다.

- **Redux 예시:** Redux Toolkit을 사용하면 보일러플레이트를 줄여 쉽게 전역 상태를 정의할 수 있습니다. Store를 만들고 `<Provider store={store}>`로 앱을 감싸면, `useSelector`와 `useDispatch`로 어디서든 상태 조회/업데이트를 할 수 있습니다. (코드 예시는 길어서 생략하지만, Redux를 통해 액션을 디스패치하면 리듀서가 새로운 state를 만들고, 해당 state 조각을 구독하는 컴포넌트들이 재렌더링되는 흐름입니다.)

- **Context + useReducer 패턴:** Redux를 쓰지 않고도 Context에 `useReducer`를 결합하면 비슷한 패턴을 구현할 수 있습니다. 작은 앱에서는 `AppContext`를 만들고 `useReducer`로 state와 dispatch를 제공하여, 전역 Redux 없이 "mini-Redux"처럼 쓰는 경우도 있습니다.

- **Zustand, Jotai 등**: 비교적 새로운 경량 상태 라이브러리는 React Context보다 성능 최적화가 쉽고, Redux보다 사용이 간단한 대안들입니다. 예를 들어 Zustand는 Hook 기반으로 전역 상태를 정의하고 개별 컴포넌트는 `useStore`로 필요한 부분만 구독합니다. Jotai는 원자 단위 상태를 관리하여 일부 atom이 바뀌어도 관련 컴포넌트만 업데이트되는 **fine-grained** 전역 상태관리를 제공합니다.

**언제 사용해야 하나:** **애플리케이션 규모 및 복잡도**가 일정 수준 이상이면 전역 상태 패턴 도입을 고려해야 합니다. 구체적으로:

- **Redux**: 큰 규모 앱에서 엄격한 패턴, 미들웨어, 개발자 도구, 타입 안정성이 필요할 때 적합합니다 (예: 수십 개 이상의 상태 슬라이스, 복잡한 비동기 로직). Redux Toolkit으로 보일러플레이트를 줄이고, 필요하면 RTK Query로 데이터 패칭도 함께 관리합니다. **엔터프라이즈급 앱**에 많이 쓰입니다 ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=,renders%20matter)) ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=When%20to%20Use%20Redux%20)).
- **Zustand**: 더 가벼운 대안을 원하거나 Redux의 양식을 따르지 않고 싶을 때. 중간 규모 앱에서 **보일러플레이트 없이 전역 상태**를 쓰고 싶을 때 사용합니다. 성능 최적화가 내장되어 있고, API도 단순합니다. Redux의 엄격함보다 유연함을 선호하면 좋습니다 ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=,bundle%20size%20is%20a%20concern)).
- **MobX**: **관찰자 패턴** 기반으로, 객체의 변화를 자동 추적하여 반영합니다. 함수형보다는 객체 지향 접근이라好好. 현재는 예전만큼 대세는 아니지만 **포밍**이나 간단한 global observable state에는 사용되기도 합니다.
- **Context+Reducer**: 전역 상태가 그리 많지 않고 별도 라이브러리 없이 해결하고 싶다면, 직접 Context를 만들어 `useReducer`로 store처럼 쓰는 방법도 있습니다. Next.js App Router에서 `layout.tsx`에 Provider를 넣어 페이지 전환 간 상태를 유지하는 식으로 활용 가능합니다.
- **React Query 등 서버 상태**: 서버에서 불러온 데이터(예: API 응답 캐시)는 Redux보다는 **React Query, SWR** 같은 전문 라이브러리로 관리하는 것이 효율적입니다. 이는 후술하는 비동기 렌더링 패턴에서 다룹니다.

**장점:**

- **중앙 집중 관리:** 한 곳에 상태를 모아두고 관리 규칙을 적용하므로 상태 변화가 예측 가능하고, **디버깅**이나 로그 추적이 용이합니다. Redux의 경우 엄격한 패턴 덕에 팀원 간 코드 일관성도 높습니다 ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=When%20to%20Use%20Redux%20)).
- **아무 곳에서나 접근 가능:** 전역 스토어/컨텍스트로 제공되기 때문에 **props 없이** 필요한 컴포넌트가 state를 구독할 수 있습니다. 깊은 트리 구조에서도 편리합니다.
- **리렌더 최소화(라이브러리마다 다름):** Zustand나 Jotai처럼 필요한 부분만 구독하거나 atom 단위 업데이트가 가능한 라이브러리는, Context의 단점인 불필요한 리렌더를 줄여 **성능 효율적**입니다 ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=,bundle%20size%20is%20a%20concern)) ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=,bundle%20size%20is%20a%20concern)).
- **강력한 개발 도구 (Redux):** Redux DevTools로 시간 여행 디버깅, 액션 검사, 상태 스냅샷 등 **고급 디버깅**이 가능합니다. 큰 프로젝트에서 문제 추적에 큰 도움이 됩니다.

**단점:**

- **복잡도 및 러닝커브:** Redux 같은 패턴은 개념(액션, 리듀서, 미들웨어 등)과 코드 구조를 익혀야 하며, 초기 설정에 노력이 듭니다. 작은 프로젝트에선 **과도한 무게**가 될 수 있습니다.
- **보일러플레이트:** (Redux 기준) 아무리 Toolkit을 써도 액션 생성, 슬라이스 정의 등 코드가 늘어납니다. 타입스크립트와 결합하면 액션 타입, 디스패치 타입 정의 등이 추가되어 장황해질 수 있습니다.
- **개발자 도구 의존:** 전역 상태가 커지면 DevTools 없이 디버깅하기 어렵고, state shape을 한눈에 이해하기 힘들 수 있습니다. 항상 구조를 문서화하고 잘 관리해야 합니다.
- **추적 어려움 (전역 남용 시):** 너무 모든 것을 전역 상태로 두면 컴포넌트 내부의 self-contained한 로직이 줄어들고, 작은 변화도 전역 상태를 통해 흘러가야 하므로 오히려 흐름을 따라가기 어려워질 수 있습니다. 필요한 부분만 전역으로, 나머지는 로컬 state로 남기는 **균형 잡기**가 중요합니다.

> **결론:** 전역 상태 관리 패턴은 상황에 맞게 선택해야 합니다. **작은 앱**은 Context나 간단한 Reducer로 충분하고, **중간 규모**는 Zustand 같은 경량 상태, **대규모**는 Redux가 유효합니다 ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=,renders%20matter)) ([State Management in 2025: When to Use Context, Redux, Zustand, or Jotai - DEV Community](https://dev.to/hijazi313/state-management-in-2025-when-to-use-context-redux-zustand-or-jotai-2d2k#:~:text=When%20to%20Use%20Redux%20)). 데이터 패칭 등 **서버 상태**는 React Query처럼 특화된 툴을 활용하세요.

### 파생 상태(Derived State) 및 단일 원본 원칙

**개요:** React에서는 **가능하면 필요한 데이터는 계산해서 사용할 것**을 권장하며, 중복된 상태를 두지 않는 것이 패턴입니다. 예를 들어, props로 주어진 목록의 정렬된 결과를 state로 또 보관하지 않고, render 시 정렬하거나 `useMemo`로 계산합니다. 이러한 접근을 통해 **불필요한 상태**를 줄이고 **단일한 소스**에서 파생하여 쓰는 습관이 중요합니다.

**사용 사례:** 상태 A로부터 결정되는 값 B를 굳이 useState로 관리하지 않고, JSX에서 바로 표현식으로 계산하거나, 비싼 연산이면 `useMemo`를 써서 A가 변할 때만 B를 재계산하는 식으로 처리합니다. 예를 들어 폼에서 이름과 성을 입력받아 fullname을 보여줄 때 fullname을 별도 state로 두지 않고, `const fullName = firstName + " " + lastName;`으로 그때그때 만들거나, 컴포넌트에서 `firstName`이나 `lastName`이 바뀔 때만 fullName을 memoize합니다. 또한, 여러 state로 나뉘어 있는 값을 하나의 state로 묶거나 (필요시), 반대로 하나의 state 객체를 불필요하게 크게 쓰고 있다면 쪼개는 등 **state 구조를 최적화**합니다. 이 역시 패턴이라기보다는 **모범 사례**에 가깝지만, 언급할 가치가 있습니다.

**언제 사용해야 하나:** **어떤 값이 다른 값에 100% 의존**하여 항상 동시에 바뀐다면 굳이 두 개의 상태로 관리하지 마세요. 하나만 관리하고 다른 하나는 **파생 계산**하세요. React 공식 문서에서도 "중복된 state를 가지지 말고 필요하면 계산해 쓰라"는 조언을 하고 있으며, Effect를 잘못 사용해서 파생 값을 동기화하려 들지 말라고 강조합니다 ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=As%20of%202023%2C%20the%20official,Should%20you%20add%20memo%20everywhere)). 이는 **불변성** 유지 및 **렌더링 단순성** 측면에서도 중요합니다.

**장점:**

- **버그 감소:** 하나의 소스만 관리하면 동기화 이슈가 사라집니다. 두 상태가 엇나가 서로 다른 값을 갖는 상황이 없으므로 **데이터 무결성**이 유지됩니다.
- **코드 단순화:** 중복 관리 로직이 없어져 코드양이 줄고, 상태 의존 관계를 머릿속으로 쫓지 않아도 됩니다. 유지보수가 쉬워집니다.
- **렌더 효율:** 파생 값을 state로 가지면 setState할 때마다 렌더링 되지만, 계산으로 처리하면 불필요한 렌더를 줄일 수 있습니다. (필요시 useMemo로 캐싱)

**단점:**

- **실시간 계산 비용:** 매우 복잡한 계산을 매 렌더마다 하면 성능 문제가 될 수 있습니다. 이 경우 `useMemo`로 최적화하되, 의존 상태가 바뀔 때만 계산하도록 조정하면 됩니다.
- **과도한 파생 처리:** 때론 가독성을 위해 중간 값을 state로 저장하는 편이 이해가 쉬울 수 있습니다. 너무 억지로 파생시키려 하면 코드가 난해해질 수 있으므로, 단순한 계산이 아닐 땐 state로 관리하고 적절히 동기화하는 것이 나을 수도 있습니다. (그러나 이 경우도 effect 동기화보다는 수동 조작 권장)

> **예시:** 다음과 같은 안티패턴은 피하세요. `const [count, setCount] = useState(0); const [double, setDouble] = useState(0); useEffect(() => { setDouble(count * 2); }, [count]);` 대신, double은 `count * 2`로 필요할 때 계산하면 됩니다. 별도 state로 둘 필요가 없습니다.

## 고급 구성 기법 (Advanced Composition Techniques)

앞서 소개한 패턴들을 보완하거나 특수한 목적을 위한 고급 패턴들이 있습니다. 고급 구성 기법은 **컴포넌트의 기능을 더 유연하게 확장**하거나, **React의 특수한 API를 활용**하는 방법들을 포함합니다. 이 섹션에서는 **커스텀 Hooks**, **포털(Portal)**, **forwardRef**, **에러 바운더리** 등 고급 주제를 다룹니다.

### 커스텀 훅 패턴 (Custom Hooks for Reusable Logic)

**개요:** React Hooks의 등장으로, 컴포넌트 로직을 **함수 형태로 추출해 재사용**하는 것이 가능해졌습니다. **커스텀 Hook**은 `useSomething` 형태의 함수를 만들어 내부에서 다른 훅들을 사용함으로써 상태 로직을 캡슐화하는 패턴입니다. 컴포넌트 간에 중복되는 로직(예: 데이터 가져오기, 이벤트 리스너 등록, 폼 핸들링 등)을 HOC나 Render Props 없이 공유할 수 있어 React 16.8 이후로 **가장 선호되는 코드 재사용 패턴**이 되었습니다 ([Hooks Pattern](https://www.patterns.dev/react/hooks-pattern#:~:text=Although%20Hooks%20are%20not%20necessarily,can%20be%20replaced%20by%20Hooks)).

**사용 사례:** 여러 컴포넌트에서 공통으로 쓰이는 **상태 관련 로직**은 커스텀 Hook으로 빼내기 좋습니다. 예를 들어 **브라우저 창 크기 추적**(resize 이벤트 리스너) 로직이 필요한 여러 컴포넌트가 있다면 `useWindowSize` Hook을 작성하여 `width`와 `height`를 반환하도록 할 수 있습니다. 이후 어떤 컴포넌트든 `const { width, height } = useWindowSize();`로 현재 창 크기를 쉽게 얻습니다. 또, **API 호출 및 캐싱 로직**을 `useFetchData`같은 Hook으로 만들어두면 다양한 데이터 요청에 활용할 수 있습니다. **Form 입력 관리**도 `useFormFields`로 필드 state와 onChange 처리를 캡슐화할 수 있고, **Debounce**도 `useDebounce(value, delay)`로 만들어 쓰면 편리합니다. 아래는 `useLocalStorage`라는 커스텀 Hook 예시입니다.

```tsx
// useLocalStorage.ts - 로컬스토리지에 상태 저장 Hook 예시
import { useState, useEffect } from 'react';

export function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    // 초기값을 우선 로컬스토리지에서 가져옴
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem(key);
      if (saved != null) return JSON.parse(saved);
    }
    return initialValue;
  });

  useEffect(() => {
    // 값이 바뀔 때 로컬스토리지에 저장
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue] as const;
}

// 사용예시
function Settings() {
  const [username, setUsername] = useLocalStorage<string>('username', '');
  // 이제 username 상태는 새로고침해도 localStorage 통해 복원됨
  ...
}
```

`useLocalStorage` Hook은 키와 초기값을 받아 state를 관리하고, side effect로 localStorage 동기화까지 캡슐화합니다. 이 Hook을 쓰는 컴포넌트는 내부 구현 신경 없이 `[value, setValue]`만 받아 쓰면 됩니다.

**언제 사용해야 하나:** 컴포넌트 로직 중 **다른 곳에서도 동일하게 활용될 부분**이 보이면 그걸 Hook으로 만들 시점입니다. 예를 들어:

- 하나 이상의 컴포넌트에서 **똑같은 useEffect + useState 조합**을 쓰고 있다.
- 혹은 과거 HOC로 추상화했던 로직이 있다 (→ Hook으로 치환 가능).
- 또는 Render Props 기반으로 쓰던 컴포넌트가 있다 (→ 내부 로직을 Hook으로).

이런 경우 커스텀 Hook으로 변경하면 코드가 더 간결하고 이해하기 쉬워집니다. **Presentational/Container 패턴의 컨테이너** 부분도 Hook으로 대체 가능했습니다 ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=Component%20)) ([React Design Pattern](https://velog.io/@aborile/React-Design-Pattern#:~:text=hooks%EC%9D%98%20%EB%8F%84%EC%9E%85%20%EC%9D%B4%ED%9B%84%2C%20Dan%20Abramov%EA%B0%80,%EC%83%88%EB%A1%AD%EA%B2%8C%20%EC%A0%9C%EC%95%88%ED%95%9C%20%EB%B0%A9%EC%8B%9D%EC%9D%B4%EB%8B%A4)). Next.js에서도 서버와 상관없는 클라이언트 로직은 대부분 Hook으로 분리해 관리하는 편입니다.

**장점:**

- **쉬운 로직 공유:** Hook은 함수이므로 가져와서 호출만 하면 됩니다. HOC처럼 JSX를 감싸거나 Render Prop으로 중첩함 없이 **직접 값을 반환**받아 사용할 수 있어 직관적입니다 ([Render Props – React](https://legacy.reactjs.org/docs/render-props.html#:~:text=the%20new%20React%20docs.%20,been%20replaced%20by%20custom%20Hooks)).
- **테스트 용이:** 로직이 UI와 분리돼 순수 함수 형태로 있기 때문에 단위 테스트하기 용이합니다. 필요한 훅들은 mocking하거나 실제 훅 동작을 이용하여 결과를 검증할 수 있습니다.
- **HOC/Render Props 대체:** Hooks로 인해 전통적인 재사용 패턴들이 거의 Hooks 기반으로 대체되었습니다. 코드량이 줄고, React DevTools에도 따로 나오지 않아 **컴포넌트 계층이 깨끗**해집니다.
- **상태ful 로직 추상화:** UI 없이도 상태 및 이펙트를 가질 수 있으므로, 사용자 인터페이스와 상관없는 **비즈니스 로직**만 따로 모듈화할 수 있습니다.

**단점:**

- **훅 간 의존성:** Hook 내부에서 다른 Hook을 사용할 때 순서와 의존성에 신경 써야 합니다. 예를 들어 `useEffect`나 `useCallback` 등을 래핑한 Hook에서는 의존성 배열 관리가 적절히 돼야 하고, 이를 사용자에게 노출할 때 API 디자인에 주의가 필요합니다.
- **추적 어려움:** 커스텀 Hook은 컴포넌트 트리에 보이지 않으므로, 중첩된 Hook 호출로 인해 벌어지는 일을 디버깅하려면 해당 Hook 코드를 직접 뒤져봐야 합니다. 컨텍스트와 비슷하게 *숨겨진 추상화 계층*이 늘어나는 셈입니다.
- **과도한 분리:** 너무 작은 로직까지 죄다 Hook으로 분리하면, 오히려 코드를 따라가기가 어려워질 수 있습니다. 적절한 수준에서만 추출하고, 컴포넌트 자체에 두는 게 명확한 로직은 그냥 두는 게 좋습니다.

> **예시:** React 공식 문서에서도 "Hook은 많은 기존 패턴을 대체한다"며, 예전 패턴(컨테이너 컴포넌트, HOC, Render Props 등)이 Hooks로 얼마나 단순해지는지 강조합니다 ([Hooks Pattern](https://www.patterns.dev/react/hooks-pattern#:~:text=Although%20Hooks%20are%20not%20necessarily,can%20be%20replaced%20by%20Hooks)). 실제로도 Hooks 도입 이후 React 커뮤니티의 패턴들은 대부분 Hook 중심으로 재편되었습니다.

### 포털 패턴 (Portal for Overlay Components)

**개요:** **Portal(포털)**은 React 컴포넌트의 렌더링 결과를 현재 컴포넌트 계층이 아닌 **DOM의 별도 위치**에 삽입하는 기법입니다. ReactDOM.createPortal를 사용하면, JSX 출력이 `<body>` 아래나 특정 DOM 노드 아래로 렌더됩니다. 주로 **모달, 툴팁, 드롭다운 메뉴** 같이 현재 DOM 계층의 제약을 벗어나 **전역 레이어**로 올려야 하는 UI를 만들 때 사용합니다. 이를 활용한 패턴이 Portal 패턴이며, 흔히 **Modal 컴포넌트 구현**에서 등장합니다.

**사용 사례:** 모달 창을 예로 들면, 모달은 화면 맨 위에 겹쳐져야 하고, 부모 컴포넌트의 CSS `overflow:hidden`이나 `z-index` 등에 간섭받지 않아야 합니다. 따라서 모달 JSX를 일반적인 부모 자식으로 렌더링하지 않고, Portal을 통해 `<div id="modal-root">` 같은 DOM 컨테이너에 탈출시켜 그립니다. 이처럼 **시각적으로 독립적인 레이어**가 필요한 UI는 Portal로 구현합니다. React 개발에서는 `<Toast>` 알림, `<DropdownMenu>` 등이 Portal로 구현되는 경우가 많습니다. Next.js에서는 `Modal`을 페이지 간 공유 상태로 만들 때 Portal을 쓰기도 합니다 (특히 App Router에서는 modal route 패턴이 있지만, UI 적 측면에서 Portal과 유사한 동작을 합니다).

```tsx
// Modal.tsx - 포털을 이용한 모달 컴포넌트 예시
import { createPortal } from "react-dom";

type ModalProps = { children: React.ReactNode; onClose: () => void };
export function Modal({ children, onClose }: ModalProps) {
  // 모달 루트 DOM (예: public/index.html에 <div id="modal-root"></div> 존재해야 함)
  const modalRoot =
    typeof window !== "undefined"
      ? document.getElementById("modal-root")
      : null;
  if (!modalRoot) return null;
  return createPortal(
    <div className="modal-backdrop" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>,
    modalRoot
  );
}
```

위 `Modal` 컴포넌트는 `modalRoot` DOM 노드를 찾아, 포털을 통해 모달 내용을 거기에 렌더링합니다. 배경(backdrop) 클릭 시 `onClose` 호출로 모달을 닫고, 내용 클릭은 이벤트 전파를 막아 닫히지 않게 하는 등 모달 UX를 포함합니다. 이 Modal을 사용하면, JSX 트리 어디에서든 `<Modal>`을 렌더링해도 실제 DOM 출력은 최상위 `#modal-root` 하위로 이동합니다.

**언제 사용해야 하나:**

- CSS 상 **부모 컨테이너의 overflow, z-index 등의 영향**을 받으면 안 되는 UI를 만들 때. (예: 부모가 overflow hidden인데 그 안에 dropdown을 렌더하면 넘쳐보이지 않음 -> Portal로 body 밑으로 이동 필요)
- **DOM 계층 밖에서 렌더링되어야 의미가 있는 경우**. 예를 들어 `<head>`에 meta 태그 삽입 같은 것도 Portal 개념으로 구현 가능하지만, 일반적으론 react-helmet 같은 라이브러리 사용.
- **전역 모달, 전역 알림 등** 앱 전체에 하나만 존재하는 컨테이너에 모아서 렌더링하고 싶을 때.

Next.js App Router를 쓰는 경우, 모달을 페이지 전환과 독립적으로 유지하려면 React state로 관리하기보다 route를 쓸 수 있지만, UI적으로 overlay 띄우는 건 Portal 활용과 유사합니다. (Next 13에서는 `useRouter`로 현재 route 상태를 보고, modal route라면 Modal 컴포넌트를 일반 페이지 위에 포탈처럼 띄우는 패턴도 쓰입니다.)

**장점:**

- **레이어 분리:** DOM 구조 상 위치를 이동시킴으로써 **시각적/논리적 계층을 분리**할 수 있습니다. 부모 요소의 스타일링 문맥에서 벗어나 전역 스타일 문맥으로 그릴 수 있어, UI 깨짐 없이 오버레이 구현이 가능합니다.
- **유지보수 용이:** Portal을 사용한 컴포넌트는 자신이 어디 렌더링되는지 신경쓰지 않고 **독립적으로 구현**될 수 있습니다. 필요한 DOM 컨테이너만 정해주면 되므로, 모달/툴팁 등을 개별 컴포넌트로 추상화하기에 좋습니다.
- **캡슐화:** 내부 구현은 Portal이지만, 사용하는 입장에선 `<Modal>...</Modal>` 식으로 쓰므로 **사용법은 일반 컴포넌트와 다르지 않습니다**. 구현과 사용의 분리가 잘 되어 있습니다.

**단점:**

- **이벤트 관리 고려:** Portal로 띄운 컴포넌트도 리액트 이벤트 시스템상 기존 트리의 부모 이벤트에 참여합니다. 그러나 DOM 상 위치가 떨어져 있어 혼란이 올 수 있습니다. 예컨대 Portal 내부 요소에서 `stopPropagation`하지 않으면, React 이벤트는 부모 컴포넌트로 버블되어 갑니다(비록 DOM 트리는 다르지만) ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=All%20react%20components%20implement%20the,of%20the%20state%20and%20props)) ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=Looking%20at%20the%20documentation%20on,shallow%20comparison%20on%20every%20update)). 이런 점을 이해하고 이벤트 처리를 해줘야 합니다.
- **SSR 제약:** Portal은 브라우저 환경에서 DOM이 있어야 동작하므로, Next.js처럼 SSR에서는 `document`가 없어서 오류가 납니다. 이를 피하려면 `typeof window !== 'undefined'` 체크나, 조건부 렌더링으로 서버 렌더 단계에 Portal을 건너뛰게 해야 합니다. 또는 `useEffect`에서 모달을 띄우는 방식으로 처리합니다.
- **추가 DOM 필요:** Portal하려면 HTML에 해당 아이디의 컨테이너가 있어야 합니다. 이 설정을 누락하면 작동하지 않거나 runtime에 container를 직접 만들어야 하는 번거로움이 있습니다. 프로젝트 구조 상 Portal용 div를 미리 마련해두는 것이 좋습니다.

### ref 전달 및 조작 패턴 (Forwarding Refs)

**개요:** React에서 ref는 DOM이나 자식 컴포넌트 인스턴스를 직접 가리키는 용도로 사용됩니다. **Ref Forwarding(REF 전달)**은 React에서 제공하는 `forwardRef` API로, 부모가 부여한 ref를 자식의 특정 요소에 연결해주는 패턴입니다. 이로써 외부에서 컴포넌트의 내부 DOM에 접근하거나, 컴포넌트 간 공조가 필요한 경우 ref를 투명하게 전달할 수 있습니다. 주로 **재사용 컴포넌트 라이브러리**에서 기본 DOM 요소의 ref를 바깥으로 노출해야 할 때 쓰입니다 (예: 커스텀 Input 컴포넌트가 실제 `<input>` DOM의 ref를 전달).

**사용 사례:** 예를 들어 `<FancyInput>`라는 컴포넌트를 만들어 내부에 `<input>`을 렌더하고 여러 스타일이나 로직을 부가했다고 합시다. 이 `<FancyInput>`을 쓰는 부모가 `.focus()`를 호출하기 위해 ref를 쓰고 싶다면, FancyInput 컴포넌트 자체는 일반 객체이므로 바로 DOM을 얻을 수 없습니다. 이때 FancyInput 구현시에 `forwardRef`로 감싸고 ref를 `<input>`에 붙여주면, 부모에서 `useRef`로 받은 current가 실제 DOM input을 가리키게 됩니다. 다음은 간단한 forwardRef 예시입니다:

```tsx
import React, { forwardRef, useRef, useImperativeHandle } from "react";

type FancyInputProps = { label: string };
const FancyInput = forwardRef<HTMLInputElement, FancyInputProps>(
  ({ label }, ref) => (
    <div className="fancy-input">
      <label>{label}</label>
      <input ref={ref} /> {/* ref 전달 */}
    </div>
  )
);

// 사용측
function Parent() {
  const inputRef = useRef<HTMLInputElement>(null);
  const focusInput = () => {
    inputRef.current?.focus();
  };
  return (
    <>
      <FancyInput ref={inputRef} label="Name" />
      <button onClick={focusInput}>Focus the input</button>
    </>
  );
}
```

FancyInput에서 `forwardRef`를 사용하여 넘어온 ref를 내부 `<input>`의 ref prop에 연결했습니다. Parent 컴포넌트는 FancyInput에 ref를 전달했고, 그 ref의 current가 FancyInput 내부의 진짜 `<input>` 요소가 됩니다. 이로써 Parent에서 `focus()`를 호출할 수 있게 되었습니다.

또한, `useImperativeHandle` 훅을 쓰면 커스텀 컴포넌트가 외부로 노출하는 인스턴스 메서드를 정의할 수도 있습니다. 예를 들어 위 FancyInput에 `focus()` 메서드를 노출하려면, forwardRef 안에서 `useImperativeHandle(ref, () => ({ focus: () => inputRef.current?.focus() }))` 등을 사용해 custom handle을 제공하면 됩니다. 이 역시 고급 패턴으로, 주로 **비제어 컴포넌트 제어**나 **라이브러리 interoperability**에 쓰입니다.

**언제 사용해야 하나:**

- **컴포넌트 라이브러리 제작 시**: Button, Input 등 기본 요소를 감싼 컴포넌트에서 원본 DOM에 대한 ref 접근을 열어주어야 할 때. 사용자가 이 컴포넌트를 쓸 때 원래 DOM 요소와 동일하게 취급하기 원하면 forwardRef 지원은 필수입니다.
- **포커스 관리 등 DOM 제어 필요**: 부모가 자식 특정 요소에 포커스하거나 크기 측정 등 DOM 조작을 해야 하는데, 그 요소가 여러 래퍼 안에 있을 때 ref forwarding으로 연결합니다.
- **모달/포커블 UI**: 모달이 열릴 때 특정 버튼에 포커스를 주거나, 외부에서 특정 UI를 스크롤시키거나 할 때 등.

**장점:**

- **유연한 캡슐화**: 컴포넌트를 추상화하면서도 필요한 경우 내부 DOM에 접근할 수 있어, **추상화 계층을 침투할 수 있는 구멍**을 적절히 제공합니다. 완전히 캡슐화해 버리면 못하는 일을 가능케 해줍니다.
- **호환성**: 기존 DOM API나 다른 라이브러리와 통합하기 용이합니다. 예를 들어, 어떤 서드파티 플러그인이 특정 DOM 요소를 필요로 한다면, 우리의 React 컴포넌트가 forwardRef로 그 DOM을 제공해줄 수 있습니다.
- **명시적 제어**: useImperativeHandle과 함께 쓰면 외부에 제공되는 메서드를 제한/정의할 수 있어, uncontrolled 컴포넌트를 controlled처럼 제어하는 인터페이스를 만들 수 있습니다.

**단점:**

- **복잡성 증가**: forwardRef 사용 시 제네릭 타입 다루기 등 구현이 조금 복잡해질 수 있습니다. (특히 TypeScript에서 props와 ref의 제네릭을 맞물리는 부분)
- **남용 주의**: ref는 React의 선언적 데이터 흐름을 벗어나 직접적인 조작을 가능하게 하므로, 너무 자주 사용하면 안티패턴이 될 수 있습니다. 가능하면 상태와 props로 해결하고, 정말 필요할 때만 ref를 사용해야 합니다.
- **Hook과의 조합**: 함수 컴포넌트에서 ref forwarding을 하면서 내부 훅 사용 시, useImperativeHandle 등 추가 API 사용이 필요해 코드량이 늘고 테스트가 약간 어려워질 수 있습니다.

### 에러 바운더리 (Error Boundary) 패턴

**개요:** **에러 바운더리(Error Boundary)**는 컴포넌트 렌더링 중 발생하는 JavaScript 오류를 잡아내어 애플리케이션 전체가 깨지는 것을 방지하고, 폴백 UI를 보여주는 패턴입니다. React 클래스 컴포넌트의 `componentDidCatch` 또는 함수 컴포넌트에서 최신에 도입된 `useErrorBoundary` (또는 React 18의 `ErrorBoundary` 컴포넌트 – 아직 제안) 등을 사용해 구현합니다. Next.js 13 app 디렉토리에서는 `error.jsx` 파일로 경로별 에러 바운더리를 구성하기도 합니다. 에러 바운더리는 주로 **네트워크 에러, 렌더링 에러 등에 대한 폴백 UI** (예: “Something went wrong” 화면)를 보여주기 위해 도입합니다.

**사용 사례:** 서버에서 가져온 데이터 구조가 예상과 다르거나, 컴포넌트 내부 버그로 runtime 에러가 발생할 수 있는 부분에 Error Boundary를 배치합니다. 예를 들어, 전체 앱을 `<AppErrorBoundary>`로 감싸 전역 에러 처리도 가능하고, 특정 중요한 위젯 주위에만 국지적으로 사용할 수도 있습니다. 라이브러리 사용 시 그 내부에서 throw하는 에러를 감싸 처리할 때도 씁니다. Next.js App Router에서는 각 segment에 `error.tsx`를 두면 그 영역에서 에러시 해당 UI를 보여주므로, ErrorBoundary와 유사하게 동작합니다.

```tsx
// AppErrorBoundary.tsx - 에러 바운더리 구현 (클래스 컴포넌트 방식)
import { Component, ErrorInfo, ReactNode } from "react";
type Props = { children: ReactNode; fallback?: ReactNode };
type State = { hasError: boolean };
export class AppErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };
  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
    // 로그 전송 등
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback || <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

함수 컴포넌트로는 공식적으로 Error Boundary 훅이 없지만, 외부 라이브러리(`use-error-boundary`) 등을 쓰거나 React 팀의 future API를 기다려야 합니다. 따라서 위처럼 클래스로 구현하는 것이 일반적입니다.

**언제 사용해야 하나:**

- **사용자에게 안정적인 UI 제공**: 프로덕션 환경에서 발생할 수 있는 예외로 앱이 하얗게 멈추는 것을 피하려면, 적절한 범위에 에러 바운더리를 배치합니다. 예를 들어 전체 페이지를 감싸 전역 에러 메시지를 띄우거나, 개별 위젯에 문제가 생겨도 나머지 페이지는 살아있게 할 수 있습니다.
- **서버 오류 처리**: 데이터 패칭 중 에러가 발생하면 throw하거나 Promise reject될 수 있는데, 이를 ErrorBoundary + Suspense 조합으로 처리하면 깔끔합니다. React 18에서는 Suspense for Data Fetching과 함께 ErrorBoundary로 로딩/에러 UI를 구성하는 패턴이 있습니다.
- **로그 수집**: ErrorBoundary의 `componentDidCatch`에서는 오류와 스택 정보를 받을 수 있으므로, Sentry 같은 오류 수집 서비스에 전송하거나 자체 로깅을 할 수 있습니다.

**장점:**

- **안정성 향상**: 에러가 발생해도 사용자가 빈 화면을 보는 대신 대체 UI를 보게 되어, **UX가 향상**되고 치명적 오류에도 일부 기능이 동작하도록 할 수 있습니다.
- **지역적 처리**: ErrorBoundary를 여러 곳에 두면, 하나의 위젯 오류가 다른 부분에 영향 주지 않도록 **격리**할 수 있습니다. 예를 들어 댓글 위젯에 오류가 나도 나머지 콘텐츠는 표시되게.
- **디버깅 보조**: 개발 시 console.error로 오류와 스택이 출력되어, 어디서 문제가 났는지 파악하기 수월합니다. (물론 ErrorBoundary 없을 때도 콘솔에 오류는 뜨지만, boundary를 통해 더 세부 처리를 할 수 있음)

**단점:**

- **에러 경로 복잡성**: ErrorBoundary로 잡은 이후의 처리 로직이 복잡해질 수 있습니다. 예를 들어 한 번 오류가 난 컴포넌트를 재시도하려면 state를 리셋하거나 해야 하는데, 이런 관리까지 필요합니다. Next.js의 `error.tsx`도 재시도 버튼 구현을 위해 `useEffect`로 상태 초기화를 하는 등 추가 코드가 필요합니다.
- **Hook과 함께 쓰기 제한**: 현재 함수 컴포넌트에서는 ErrorBoundary를 훅으로 간단히 쓸 수 없어서(React 팀에서 논의 중) 클래스 컴포넌트를 유지해야 하는 번거로움이 있습니다. 프로젝트 전체를 함수 컴포넌트로 짰다면, ErrorBoundary만 클래스로 따로 두는 형태가 됩니다.
- **비동기 에러는 못잡음**: ErrorBoundary는 render나 lifecycle 중 throw된 에러만 잡습니다. 즉, `setTimeout`이나 이벤트 핸들러, 또는 네트워크 요청 Promise의 에러 등 **비동기적으로 발생하는 예외는 잡지 못합니다**. 이러한 경우는 try-catch나 `.catch`로 직접 처리해야 합니다. (React 18에서 `use`로 인한 async 오류는 ErrorBoundary로 잡히지만, 일반적인 비동기는 아님)

## 비동기 렌더링 (Asynchronous Rendering Patterns)

React 18 이후로 **Concurrent Features(동시성 기능)**가 도입되면서, 비동기 작업과 렌더링을 관리하는 새로운 패턴들이 등장했습니다. 또한 데이터 패칭 및 코드 분할에 관한 기존 패턴들도 더 발전했습니다. 이 섹션에서는 **Suspense를 활용한 비동기 처리**, **트랜지션(startTransition)**, **deferred 값(useDeferredValue)**, **React 18의 자동 배칭**, **Next.js 13 서버 컴포넌트** 등을 다룹니다.

### 코드 스플리팅 및 다이나믹 임포트 (React.lazy & Suspense)

**개요:** **코드 스플리팅(Code Splitting)**은 번들 크기를 줄이고 초기 로드를 빠르게 하기 위해, 필요한 시점에 코드를 불러오는 패턴입니다. React에서는 `React.lazy()`와 `<Suspense>`를 사용해 컴포넌트를 지연 로딩할 수 있습니다. 예를 들어, 처음엔 가벼운 코드만 보내고, 특정 경로로 진입하거나 버튼을 눌렀을 때 추가 기능을 동적으로 import합니다. Next.js도 dynamic import 기능 (`next/dynamic`)을 제공하며, 내부적으로 React.lazy와 Suspense를 사용합니다. Suspense 컴포넌트는 lazy 컴포넌트나 데이터가 로드될 때 **로딩 UI(fallback)**를 보여주는 역할을 합니다.

**사용 사례:**

- **라우트 기반 분할**: 페이지별로 별도 청크를 만들고, 사용자가 해당 페이지로 이동할 때 비로소 JS를 불러오게 할 수 있습니다 (Next.js는 자동으로 해줌). Create React App 등의 SPA에서도 React.lazy로 페이지 컴포넌트를 지연 임포트합니다.
- **상태별 분할**: 어떤 UI 요소가 특정 상호작용 뒤에 나타나는 경우, 그 부분을 lazy로 감쌀 수 있습니다. 예를 들어 모달을 열기 전까지 모달 관련 코드 로드를 미루거나, 대형 이미지 갤러리를 사용자 요청 시에만 로드하는 식입니다.
- **서드파티 라이브러리 지연**: 초기 필요 없지만 나중에 쓰일 수도 있는 무거운 라이브러리는 dynamic import로 분리합니다. 예를 들어, 일러스트 편집기 기능을 사용자 클릭 시 로드하거나, 차트 라이브러리를 실제 보고서 페이지에 들어갈 때 로드하는 등.

```tsx
// Dynamic import example with React.lazy and Suspense
import { Suspense, lazy } from "react";
const HeavyComponent = lazy(() => import("./HeavyComponent"));

function MyComponent() {
  const [show, setShow] = useState(false);
  return (
    <div>
      <button onClick={() => setShow(true)}>Show Heavy Component</button>
      <Suspense fallback={<div>Loading...</div>}>
        {show ? <HeavyComponent /> : null}
      </Suspense>
    </div>
  );
}
```

위 코드에서 `HeavyComponent`는 lazy로 선언되어, 실제로 `show` 상태가 true가 되기 전까지 번들에 로드되지 않습니다. Suspense의 fallback으로 "Loading..."이 잠깐 표시되고, HeavyComponent 코드를 네트워크로 불러와 로드 완료되면 정상 렌더됩니다.

**언제 사용해야 하나:**

- **번들 크기 최적화**: 초기 로드 시 꼭 필요하지 않은 코드는 모두 분할 대상입니다. 초기 화면에 나타나지 않는 UI, 사용자가 특정 액션을 취해야 보이는 UI 등을 candidate로 삼습니다.
- **성능 중요한 앱**: 모바일 환경처럼 네트워크가 느리거나, 앱 규모가 커서 한번에 모든 JS를 보내면 로딩이 너무 오래 걸리는 경우, 코드 분할은 필수적인 최적화입니다.
- **Next.js 활용**: Next.js App Router에서는 기본적으로 각 segment를 분리하므로 개발자가 직접 lazy할 필요는 줄었지만, 클라이언트 전용 컴포넌트 중 무거운 것은 `dynamic()`으로 lazy 처리할 수 있습니다.
- **조건부 의존성**: 어떤 페이지에서만 필요한 라이브러리를 전역 번들에 포함시키고 싶지 않을 때 dynamic import해서 그 페이지에서만 로드되게 합니다.

**장점:**

- **초기 로드 시간 감소**: 불필요한 자바스크립트를 늦게 로드하므로 **First Load** 성능이 개선됩니다. 사용자 체감 성능(첫 화면 표시 등)이 좋아집니다.
- **네트워크 트래픽 감소**: 필요한 코드만 전송하므로, 사용자가 쓰지 않는 기능에 대해 데이터 다운로드를 절약합니다. 특히 모바일 데이터 환경에서 유리합니다.
- **캡슐화**: React.lazy와 Suspense 덕에 UI 코드를 크게 수정하지 않고도 분할을 적용할 수 있습니다. 컴포넌트 경계를 기준으로 자연스럽게 분할 가능하여 관리가 쉽습니다.

**단점:**

- **Lazy 컴포넌트 경계 필요**: Suspense로 감싸야 하므로 UI 코드에 약간의 변화가 필요합니다. Suspense fallback 디자인도 필요하며, Nested Suspense를 쓰는 경우 어떤 fallback을 어디서 보여줄지 고민해야 합니다.
- **초기 지연**: 분할된 코드를 실제 쓰려고 할 때 **네트워크 지연 + 로딩 시간**이 추가됩니다. 사용자에게 Loading UI를 보여줘야 하고, UX를 해치지 않도록 신경써야 합니다. 분할이 너무 쪼개져도 오버헤드가 커질 수 있습니다.
- **에러 처리**: Lazy import 실패(네트워크 에러 등) 시 이를 감싸는 ErrorBoundary가 있어야 대응 가능합니다. Suspense fallback은 로딩에 대한 것이고, 에러 시 대처는 ErrorBoundary로 해야 합니다.
- **복잡성 증가**: 번들링 설정에 따라 작동 방식이 달라질 수도 있고, dynamic import가 제대로 되게 빌드 환경 설정을 해야 합니다 (Webpack, Vite 등은 기본 지원). 또한, 너무 과도한 dynamic import는 유지보수성 저하 우려도 있습니다.

### Suspense를 활용한 데이터 패칭 (Suspense for Data Fetching)

**개요:** React 18에서는 **Suspense를 데이터 패칭에도 활용**할 수 있게 되었습니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=Another%20important%20new%20concurrent%20feature,splitting)) ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=match%20at%20L533%20Using%20React,the%20component%20is%20still%20loading)). 전통적으로는 `useEffect`로 데이터 로드 상태를 관리하고 로딩 스피너를 보여줬지만, 이제는 **의도적으로 컴포넌트 렌더링을 일시 중단**하고 그 사이 fallback UI를 보여주는 방식으로 처리할 수 있습니다. React 18+Next.js 13 조합에서는 서버 컴포넌트에서 `fetch` 사용 및 Suspense로 스트리밍하는 등 다양한 패턴이 가능합니다. Suspense를 이용하면 데이터가 올 때까지 하위 컴포넌트 렌더링을 보류하고, 도착하면 자동으로 렌더를 이어서 합니다. 이를 지원하는 라이브러리로 Relay, React Query (일부 실험적) 등이 있고, Next.js는 내부적으로 이를 활용합니다.

**사용 사례:**

- **React 18 서버 컴포넌트**: Next.js App Router에서 서버 컴포넌트는 `await`으로 데이터 가져오고 JSX를 반환하는데, 이때 자동으로 Suspense 경계를 통해 클라이언트에 스트림 전송됩니다. 예를 들어 `export default async function Page() { const data = await getData(); return <div>{data.title}</div>; }`에서, 데이터 지연 시 Next.js가 `<Loading/>` 컴포넌트를 보여주도록 설정할 수 있습니다 (layout에서 `Suspense fallback`).
- **클라이언트 컴포넌트에서 Suspense**: React Query의 experimental한 `useHydrateSuspense` 패턴이나, `use` 훅 (React 18.2 실험적)으로 Promise를 직접 처리하여 Suspense에 위임할 수 있습니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=This%20example%20assumes%20you%20use,enabled%20data%20source)) ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=In%20this%20example%2C%20the%20,replaced%20by%20the%20loading%20fallback)). 이 경우 Suspense fallback으로 깜빡거림 없이 선언적으로 로딩 UI를 넣습니다.
- **Relay (GraphQL)**: Relay는 Suspense 기반으로 데이터 패칭을 한다고 공식적으로 지원합니다. `usePreloadedQuery` 훅 등이 Suspense를 통해 데이터 준비 전까지 UI를 미룹니다.

**장점:**

- **로딩 UI 관리 단순화:** 기존에는 `isLoading` booleans와 조건부 렌더링이 곳곳에 필요했다면, Suspense 덕에 **로딩 상태를 선언적으로 처리가능**합니다. 여러 하위 컴포넌트에서 데이터를 불러와도 상위에서 한꺼번에 fallback을 지정할 수 있습니다.
- **동시성 최적화:** 여러 비동기 소스가 있을 때, 가장 **빠른 것들은 먼저 렌더링**하고 느린 것들은 Suspense로 늦게 합류시키는 패턴을 취할 수 있습니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=,take%20longer%20to%20fetch%20data)). 부분적으로 데이터가 준비되면 UI 일부를 먼저 보여주는 **타임슬라이싱** 효과를 쉽게 구현 가능합니다.
- **Next.js 통합:** Next.js 13에서는 Suspense/Boundary 개념을 파일 기반으로 지원 (`loading.js`, `error.js`). 이로 인해 데이터 로딩 및 에러 처리가 이전보다 체계적으로 이루어집니다. 개발자가 try-catch, isLoading을 직접 쓰는 경우가 줄었습니다.

**단점:**

- **러닝커브:** Suspense를 이용한 패칭은 개념이 완전히 익숙하지 않을 수 있습니다. 특히 기존 패턴과 섞어 쓰면 헷갈릴 수 있어 팀 내 표준을 정해야 합니다.
- **제한 사항:** Suspense로 모든 케이스를 처리할 순 없습니다. HTTP 에러 등의 경우 ErrorBoundary와 함께 써야 하고, Suspense는 아직 Concurrent Rendering 환경에서만 제대로 동작하는 측면이 있어, SSR/CSR 전환 간에 복잡성이 있습니다.
- **서드파티 의존성:** React 자체로는 fetch를 Suspense로 쓰려면 아직 `use`라는 실험적 훅이 필요한 등, 완전히 out-of-the-box는 아닙니다. React Query, Relay처럼 이를 래핑해주는 라이브러리를 사용해야 편합니다.

> **특징 인용:** _"Suspense 기능의 진정한 강점은 Concurrent 모드와 깊이 통합되어, 우선순위가 높은 업데이트는 먼저 클라이언트에 보내고, 시간이 걸리는 부분은 나중에 스트리밍함으로써 더 부드러운 UX를 제공하는 데 있다"_ ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=The%20combination%20of%20,provides%20a%20more%20fluid%20user)). 또한 _"Suspense를 사용하면 앱의 일부를 먼저 렌더링하고, 데이터 fetch가 오래 걸리는 다른 부분은 나중에 로딩 완료 후 렌더링할 수 있어 로딩 성능이 향상된다"_ ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=,take%20longer%20to%20fetch%20data)).

### 트랜지션 (Transitions with startTransition)

**개요:** React 18의 **Transition**(전환) 기능은 `startTransition` 및 `useTransition` 훅을 통해 도입되었습니다. 이것은 어떤 상태 업데이트를 **비긴급 작업**으로 표시하여, 사용자 인터랙션과 같은 긴급 업데이트와 **우선순위를 다르게** 처리하는 기법입니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=We%20can%20mark%20an%20update,if%20they%20were%20rendered%20synchronously)). 쉽게 말해, `startTransition`으로 감싼 상태 변경은 화면 업데이트가 약간 지연되어도 괜찮다고 React에게 알려주는 것입니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=By%20wrapping%20a%20state%20update,the%20current%20user%20interface%20interactive)). React는 이를 보고 사용자 입력 처리 등 더 중요한 일을 먼저 하고, 여유가 있을 때 Transition 업데이트를 수행합니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=When%20a%20transition%20starts%2C%20the,isn%27t%20pending)). 이렇게 함으로써 사용자가 타이핑하거나 클릭하는 동안 큰 리스트를 필터링하느라 UI가 버벅이는 문제를 완화할 수 있습니다.

**사용 사례:**

- **검색 필터링 예시**: 사용자가 검색어를 입력할 때마다 거대한 리스트를 필터링하여 렌더링하면, 입력 타이핑이 버벅입니다. 이때 `setInputValue` 업데이트는 즉시 (긴급)하고, 리스트 필터링 `setFilterQuery` 업데이트는 `startTransition`으로 감싸 비긴급으로 처리하면, **타이핑 응답성**은 유지되고 리스트는 약간 늦게 업데이트됩니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=Using%20a%20transition%20would%20be,startTransition)) ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=directly%20updating%20the%20value%20passed,startTransition)).
- **애니메이션 및 레이아웃 변화**: 드래그 앤 드롭 같은 UI에서, 드래그 중엔 프레임률이 중요하지만 드롭 후 리스트 재정렬은 조금 늦게 돼도 됩니다. 그런 경우 레이아웃 재계산 상태 업데이트를 Transition으로 처리합니다.
- **복잡한 재계산**: 차트 재렌더링, 복잡한 SVG 드로잉 등 무거운 연산을 동반하는 state 변경을 Transition으로. 사용자와 상호작용중인 부분(폼 입력 등)은 즉각 반응시키고, 차트 갱신은 뒤로 미룹니다.

```tsx
import { useTransition, useState } from "react";

function FilterableList({ items }: { items: string[] }) {
  const [query, setQuery] = useState("");
  const [filtered, setFiltered] = useState(items);
  const [isPending, startTransition] = useTransition();

  const handleInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const val = e.target.value;
    setQuery(val); // urgent update: input field updates immediately
    startTransition(() => {
      const result = items.filter((item) => item.includes(val));
      setFiltered(result); // transition update: may lag behind
    });
  };

  return (
    <div>
      <input value={query} onChange={handleInput} placeholder="Search..." />
      {isPending && <div>Filtering...</div>}
      <ul>
        {filtered.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

이 코드에서 입력값 `query`는 바로 업데이트되어 input 필드 값이 즉시 반영되고, 리스트 필터링 로직은 startTransition 안에서 이루어져 일정 지연이 허용됩니다. `isPending`으로 Transition이 진행 중인지 알 수 있어, 필터링 중임을 표시하는 UI도 넣을 수 있습니다.

**장점:**

- **UI 상호작용 개선:** 사용자 입력 이벤트에 대한 **반응 속도를 개선**합니다. 오래 걸리는 화면 업데이트를 뒤로 미뤄 사용자가 “버벅임”을 덜 느끼게 합니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=We%20can%20mark%20an%20update,if%20they%20were%20rendered%20synchronously)) ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=By%20wrapping%20a%20state%20update,the%20current%20user%20interface%20interactive)).
- **자동 배치와 결합:** React 18에서 모든 setState가 자동 배치되지만, Transition 내부에서는 낮은 우선순위끼리 배치되고, 바깥 업데이트와 분리되어 처리됩니다. 이로써 **병렬 작업**이 자연스레 수행됩니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=When%20a%20transition%20starts%2C%20the,isn%27t%20pending)).
- **간단한 API:** `useTransition` 훅을 쓰면 boolean 플래그도 얻을 수 있어, 로딩 스피너 등을 표시하기 쉽습니다. 개발자가 일일이 `setTimeout` 등을 쓰지 않아도 React 스케줄러가 알아서 처리해줍니다.
- **데드락 방지:** Transition 작업 도중이라도 더 중요한 업데이트가 오면 중간 작업을 일시 중단하거나 버릴 수 있어, 앱이 잠깐이라도 멈추지 않게 합니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=This%20interruptible%20rendering%20mechanism%20combined,fetching%20needs)).

**단점:**

- **알고리즘의 한계:** Transition이라 해도 결국 큰 연산은 해야 합니다. 단지 우선순위를 낮춘 것뿐이므로, 매우 무거운 계산은 WebWorker 등으로 옮기는 것이 근본 해결일 수 있습니다. Transition은 UX 개선 트릭이지 마법은 아닙니다.
- **상태 관리 복잡성 증가:** Transition을 도입하면 “urgent state”와 “transition state” 두 부류로 나뉩니다. 이는 코드 가독성을 약간 낮출 수 있고, 개발자가 개념을 숙지해야 합니다. 특히, `startTransition` 내부에서 이전 상태값을 참조할 때 클로저 타이밍을 잘 이해해야 합니다 (이미 captured된 변수 등이 있을 수 있음).
- **IE 등 미지원:** Concurrent features는 IE같은 오래된 브라우저에서는 폴리필이 어렵습니다 (IE는 지원 종료되었지만, 구형 환경에서는 concurrency를 완전히 활용 못할 수 있음).

> **인용:** React 공식 블로그에서는 *"startTransition을 사용하면 해당 업데이트를 '전환'으로 표시하여, 사용자 인터랙션을 유지하면서 백그라운드에서 준비할 수 있다"*고 설명합니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=We%20can%20mark%20an%20update,if%20they%20were%20rendered%20synchronously)). 또한 _"Transition 시작 시 concurrent renderer는 새로운 UI 트리를 백그라운드에서 준비하고, 브라우저가 한가할 때 DOM을 업데이트한다"_ ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=When%20a%20transition%20starts%2C%20the,isn%27t%20pending)). 이로써 _"입력 필드의 값 업데이트는 즉각 이뤄지지만, 대량 리스트 필터링은 배경에서 처리되어 타이핑이 부드럽게 된다"_ ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=Using%20a%20transition%20would%20be,startTransition)).

### 연기된 값 (Deferred Value)

**개요:** `useDeferredValue` 훅은 React 18에 도입된 API로, **특정 값의 업데이트를 지연**시켜줍니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=useDeferredValue)) ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=,a%20part%20of%20the%20UI)). 이것도 Transition과 유사한 목적이지만, state 업데이트가 아니라 **값 자체**를 늦게 따라가게 하는 방식입니다. 즉, 어떤 빠르게 변하는 값이 있고 그것을 사용해 무거운 계산을 한다면, 그 값을 deferredValue로 받아서 느리게 갱신되는 "후행 값"으로 사용할 수 있습니다. deferredValue는 현재 렌더에서 이전 값과 동일하게 유지되고, 나중에 여유 있을 때 최신 값으로 갱신됩니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=During%20the%20initial%20render%2C%20the,as%20the%20value%20you%20provided)). 이를 통해 Transition과 비슷하게, 급격한 입력 변화에 UI가 바로바로 반응하지 않고 약간 뒤따라가도록 함으로써 성능 향상을 꾀합니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=)).

**사용 사례:**

- **자동 완성 검색**: 타이핑하는 동안 추천 목록을 계속 업데이트하면, 입력마다 API 요청 및 결과 렌더로 부담이 큽니다. `useDeferredValue`를 사용해 입력값을 지연시킨 값을 기준으로 API를 호출하면, 사용자가 타이핑을 멈춘 후 약간 지난 시점의 값으로 검색하게 할 수 있습니다 (일종의 자연스러운 debouncing).
- **대형 리스트 필터**: Transition 예시와 비슷하게, filter text를 deferredValue로 만들고, 리스트 필터링은 deferredValue 기준으로 수행하면 사용자가 빨리 타이핑해도 리스트는 한 박자 늦게 바뀌어 성능이 좋아집니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=)). React는 필요 시 이전 결과를 잠깐 보여주다 최종 업데이트합니다.
- **애니메이션 프레임 동기화**: deferredValue는 내부적으로 transition을 사용하므로, 화면 업데이트를 브라우저 프레임과 조율하여 매끄럽게 하는 데 도움이 됩니다.

```tsx
import { useDeferredValue, useState } from "react";

function SearchAlbums() {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);
  const albums = useAlbumSearch(deferredQuery); // custom hook to fetch albums

  return (
    <>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      {query !== deferredQuery && <p>Loading results for "{query}"...</p>}
      <AlbumList albums={albums} />
    </>
  );
}
```

위 코드에서 `query`는 사용자가 입력하는 즉시 변하지만, `deferredQuery`는 React가 여유 있을 때까지 이전 값 유지 -> 나중에 새로운 query로 업데이트됩니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=During%20the%20initial%20render%2C%20the,as%20the%20value%20you%20provided)). 따라서 사용자가 빠르게 입력하면 `deferredQuery`는 한두 글자 뒤처진 상태가 되고, 그 동안 `AlbumList`는 이전 검색 결과를 계속 보여줍니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=)). 입력 멈추고 조금 지나면 deferredQuery가 최신으로 바뀌고, 새로운 결과가 나타납니다.

**장점:**

- **사용자 경험 부드러움:** Debounce 처럼 뚝 끊어지는 게 아니라, **이전 상태를 유지**하면서 새 결과를 준비하므로, 사용자는 리스트가 갑자기 빈 화면이 되는 게 아니라 지난 검색 결과가 보이다가 새 결과로 전환되는 흐름을 봅니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=)). 이게 심리적으로나 UX적으로 더 낫습니다.
- **구현 간편:** JS에서 수동으로 timer debounce를 짜지 않아도 React가 스케줄링해주므로, 훨씬 간단한 코드로 비슷한 효과를 얻습니다. (완벽한 debounce는 아니지만 “lagging behind”으로 동작) ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=During%20the%20initial%20render%2C%20the,as%20the%20value%20you%20provided)).
- **Transition과 결합:** 내부적으로 deferredValue는 Transition으로 구현되어 최적화되며, 개발자는 boolean 플래그도 쉽게 활용(`if (original !== deferred)`)하여 로딩 상태를 표시할 수 있습니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=)).
- **모든 타입 지원:** 숫자, 객체 등 어떤 값도 defer 가능하여, 광범위한 시나리오에 응용 가능합니다.

**단점:**

- **제어 어려움:** 얼마나 늦출지 타이밍을 개발자가 직접 지정하진 못합니다. React 스케줄러가 알아서 하므로, 원하는 만큼 딜레이를 주거나 하진 못합니다 (일반적으로는 충분히 잘 동작하지만).
- **상황 한정적 유용성:** deferredValue는 **값 변화가 연속적이고 빈번**할 때 의미 있습니다. 만약 입력이 느리게 이루어지거나 값이 가끔 바뀌는 거라면 굳이 쓸 필요가 없습니다. 어떤 값들을 defer할지 결정하는 것도 개발자 몫입니다.
- **이해 필요:** 코드 읽는 사람이 deferredValue 개념을 모르면 “이 값이 왜 늦게 따라가지?” 헷갈릴 수 있습니다. 따라서 팀원들과 공유된 이해가 필요하고, 잘못 사용하면 bug처럼 보일 수도 있습니다.

> **인용:** React 팀은 *"useDeferredValue는 React의 디바운싱 해결책으로, 높은 우선순위 업데이트가 끝날 때까지 낮은 우선순위 업데이트를 지연시킨다"*고 설명합니다 ([Understanding useDeferredValue in React: Enhancing Performance ...](https://medium.com/@ignatovich.dm/understanding-usedeferredvalue-in-react-enhancing-performance-with-deferred-rendering-ec8eb28aa997#:~:text=,priority%20updates%20are%20completed)). 공식 문서에서는 *"업데이트 시, deferred value는 이전 값을 먼저 반환하고, 새 값은 배경에서 준비된 후 나중에 반영된다"*고 되어 있습니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=During%20the%20initial%20render%2C%20the,as%20the%20value%20you%20provided)). 예제에서 *"기존 결과를 새 결과가 준비될 때까지 계속 보여주다가, 준비되면 교체한다"*는 흐름을 강조하고 있습니다 ([useDeferredValue – React](https://react.dev/reference/react/useDeferredValue#:~:text=)).

### React 서버 컴포넌트 (Next.js App Router 패턴)

**개요:** Next.js 13에서 도입된 **React Server Components(RSC)** 개념은 React를 **서버에서 렌더링**하는 동시에 **클라이언트로는 직렬화된 UI만 전송**하는 혁신적인 패턴입니다. App Router에서는 파일을 기본적으로 서버 컴포넌트로 취급하며(`'use client'` 없으면), 이러한 컴포넌트 내에서는 데이터를 직접 `await`으로 가져올 수 있습니다. 서버 컴포넌트는 **비동기 렌더링을 자연스럽게 수용**하며, Suspense 경계를 경유해 클라이언트에 스트림 됩니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=The%20combination%20of%20,provides%20a%20more%20fluid%20user)) ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=This%20interruptible%20rendering%20mechanism%20combined,fetching%20needs)). 클라이언트와 서버의 경계를 컴포넌트 단위로 분리함으로써, 데이터 가져오기 패턴이 크게 변화했습니다. 클라이언트에서는 서버 컴포넌트로부터 넘겨받은 완성된 UI나 데이터 조각을 props로 받아 사용하고, 서버 측의 코드는 번들에 포함되지 않습니다.

**사용 사례:**

- **초기 데이터 패칭**: 페이지를 그릴 때 필요한 대부분의 데이터는 서버 컴포넌트에서 `fetch`하여 바로 JSX에 반영합니다. 예를 들어 `page.tsx` (서버 컴포넌트) 안에서 `const data = await getData(); return <div>{data.title}</div>`와 같이 합니다. 클라이언트에는 hydrated JSON만 전달되고, 데이터 패칭 로직은 서버에만 남습니다.
- **DB 및 비밀 키 사용**: 서버 컴포넌트는 Node.js 환경에서 동작하므로 DB 쿼리나 시크릿 API 키 사용이 가능합니다. 예를 들어 바로 `await prisma.user.findMany()`를 호출해도 되고, 서버 파일시스템 접근도 됩니다. 이는 서버 전용 패턴으로, 민감 정보가 노출되지 않고 안전합니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=match%20at%20L507%20rendering%20logic,databases%20or%20the%20file%20system)).
- **하이브리드 구성**: 일부 UI는 상호작용이 필요해 클라이언트 컴포넌트로 만들고 (`'use client'` 선언), 그 외 부모들은 서버 컴포넌트로 유지합니다. 서버 -> 클라이언트 경계에서 props로 필요한 데이터가 전달되므로, 클라이언트 컴포넌트에서 별도 fetch 없이 props 사용이 가능합니다.

**장점:**

- **네트워크 요청 감소:** 브라우저 -> 서버 -> DB의 **왕복 횟수가 줄어듭니다**. 과거에는 CSR의 경우 브라우저가 API 요청->서버->DB->서버->응답->브라우저로 받아 UI에 세팅했지만, 이제 서버 컴포넌트 단계에서 DB까지 바로 갔다가 HTML로 응답하니 클라이언트가 추가 요청을 할 필요가 없거나 줄어듭니다.
- **번들 크기 감소:** 데이터 로직이 서버에 있으므로, 클라이언트 번들에서 빠집니다. 결과적으로 전송 JS 크기가 줄고, 실행할 JS도 줄어 **성능 향상**이 있습니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=match%20at%20L507%20rendering%20logic,databases%20or%20the%20file%20system)).
- **개발자 경험:** fetch나 DB 호출을 hooks/Effect로 감싸고 상태관리 하는 수고 없이, **평범한 async 함수 작성하듯** 코딩하면 됩니다. App Router의 파일 구조도 레이아웃, 에러, 로딩 등을 명시적으로 분리해줘 가독성이 향상됩니다.
- **SEO 및 초기 렌더링:** 서버에서 HTML을 바로 주므로 SSR의 장점(SEO, 빠른 First Paint)을 살립니다. React 18의 streaming SSR과 Suspense 결합으로, 일부 완성된 청크부터 바로 flush하여 **TTV(Time-to-view)**를 줄입니다 ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=The%20combination%20of%20,provides%20a%20more%20fluid%20user)) ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=This%20interruptible%20rendering%20mechanism%20combined,fetching%20needs)).

**단점:**

- **학습 필요:** 기존 CSR/SSR과 달라진 개념(서버/클라이언트 컴포넌트 구분)을 이해해야 합니다. 파일별 `'use client'`를 신경써야 하고, 어디서 어떤 코드를 실행하는지 주의가 필요합니다.
- **제한 사항:** 서버 컴포넌트에서는 이벤트 핸들러나 `useState`, DOM 조작 등 할 수 없습니다. 순수 UI 출력만 가능하여, 이를 모르는 개발자가 실수로 이벤트를 달면 에러가 납니다. 그러므로 **역할 분리가 명확**해야 합니다.
- **캐싱/동기화 이슈:** 서버에서 데이터를 가져오므로, 동일한 데이터를 클라이언트 상태와 함께 다룰 때 동기화가 어려울 수 있습니다. React Query 등과 혼용 시 애매해지기도 하고, 실시간 상호작용 (예: 채팅)에서는 서버 컴포넌트로만 처리하기 힘든 부분도 있습니다.
- **도구 미성숙:** (2025년 현재) Next.js App Router와 RSC 개념이 비교적 새롭고, 일부 라이브러리 호환성 문제가 남아 있습니다. 또한 debugging 시 SSR과 CSR 섞인 환경에서 문제가 발생하면 추적이 복잡할 수 있습니다.

> **인용:** Vercel 블로그에 따르면 _"Suspense와 React 서버 컴포넌트의 조합으로, 별도의 API 경로 없이도 데이터 소스(DB 등)에 직접 접근하여 렌더링 결과를 얻을 수 있다"_ ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=Using%20,In%20the)). 또한 _"Suspense와 스트리밍을 통해 우선순위 높은 업데이트는 먼저 클라이언트에 보내고, 낮은 우선순위는 기다리지 않고 나눠 보낼 수 있다"_ ([How React 18 Improves Application Performance - Vercel](https://vercel.com/blog/how-react-18-improves-application-performance#:~:text=The%20combination%20of%20,provides%20a%20more%20fluid%20user)). React 18의 이 기능들이 Next.js에 통합되어 **데이터 패칭 패턴이 진화**한 것입니다.

## 유틸 기반 패턴 (Utility-based Patterns)

React 개발에서는 특정 작업을 편리하게 하기 위한 **유틸리티 함수나 훅**을 활용한 패턴도 널리 사용됩니다. 이 섹션에서는 **성능 최적화 유틸(메모이제이션)**, **커스텀 훅 유틸리티** (예: usePrevious, useFetch 등), **불변성 관리** 등에 대해 설명합니다. 또한 이러한 패턴의 특징과 주의점도 함께 다룹니다.

### 메모이제이션 패턴 (useMemo, useCallback, React.memo)

**개요:** **메모이제이션**은 비싼 계산이나 함수/컴포넌트 재생성을 **캐싱**하여 불필요한 작업을 줄이는 패턴입니다. React에서는 `useMemo` 훅으로 값 계산 결과를 기억하고, `useCallback`으로 함수 객체를 기억하며, `React.memo` HOC로 컴포넌트 결과를 기억할 수 있습니다. 이를 통해 렌더링 성능을 최적화하고, **참조 동일성**을 유지해 하위 컴포넌트의 재렌더링을 방지할 수 있습니다 ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=As%20of%202023%2C%20the%20official,Should%20you%20add%20memo%20everywhere)). 단, 메모이제이션 자체에도 비용이 있으므로 **필요한 곳에만** 신중히 사용하는 것이 중요합니다 ([javascript - When to use useMemo and useCallback for performance optimization? - Stack Overflow](https://stackoverflow.com/questions/65020098/when-to-use-usememo-and-usecallback-for-performance-optimization#:~:text=2)).

**사용 사례:**

- **값 메모이제이션 (`useMemo`)**: 복잡한 산식이나 큰 배열/객체 변환이 렌더마다 수행된다면, `useMemo(() => computeFoo(bigData), [bigData])`로 `bigData`가 바뀔 때만 재계산하고 그렇지 않으면 이전 결과를 재사용합니다. 예: 필터된 리스트, 정렬 결과, 복잡한 수치 계산 등.
- **함수 메모이제이션 (`useCallback`)**: 자식 컴포넌트에 props로 함수를 내려주는 경우, 부모가 렌더될 때마다 함수 객체가 새로 만들어지면 자식이 불필요하게 재렌더될 수 있습니다. `useCallback(fn, [deps])`을 쓰면 deps가 변하지 않는 한 **동일한 함수 객체**를 유지하므로, 자식 입장에선 props 변경이 없다고 인식합니다. 예: 리스트 아이템에 onClick 핸들러 전달 시 등.
- **컴포넌트 메모이제이션 (`React.memo`)**: 순수 함수 컴포넌트(같은 props -> 같은 UI)라면 `export default React.memo(Component)`로 내보내 React가 **부모가 재렌더되어도 props 같으면 이 컴포넌트를 재렌더 안 함**니다. 예: 테이블의 각 행 컴포넌트가 받아오는 props (데이터 행)이 이전과 같으면 다시 안 그리도록.

**장점:**

- **성능 최적화:** 불필요한 재연산, 재생성, 재렌더를 막아주므로 CPU, 메모리 낭비를 줄입니다. 특히 큰 목록, 복잡한 연산에서는 체감 성능 향상이 있습니다 ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=As%20of%202023%2C%20the%20official,Should%20you%20add%20memo%20everywhere)) ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=,rendering%20logic%20is%20expensive)).
- **불변성 패턴 보조:** React는 참조 비교로 변경 감지하기 때문에, memo를 사용하면 **객체 참조 동일성**을 보장하는 방향으로 코딩하게 됩니다. 자연스럽게 불변 데이터 관리와 궁합이 맞습니다.
- **쉬운 적용:** 필요에 따라 해당 부분 코드에 한두 줄 추가하는 것으로 적용 가능하여, 리팩토링 부담이 적습니다. 성능 문제가 드러날 때 국소 최적화에 유용합니다 ([javascript - When to use useMemo and useCallback for performance optimization? - Stack Overflow](https://stackoverflow.com/questions/65020098/when-to-use-usememo-and-usecallback-for-performance-optimization#:~:text=2)).

**단점:**

- **남용시 오버헤드:** 모든 것에 useMemo/Callback을 둘러버리면, 오히려 각 렌더마다 메모이제이션 체크 비용과 메모리 사용이 늘어 **성능이 떨어질 수 있습니다** ([javascript - When to use useMemo and useCallback for performance optimization? - Stack Overflow](https://stackoverflow.com/questions/65020098/when-to-use-usememo-and-usecallback-for-performance-optimization#:~:text=2)). 즉, _“불필요한 useMemo/useCallback은 안 하느니만 못”_ 입니다.
- **가독성 저하:** 곳곳에 memoization 훅을 쓰면, 코드가 장황해지고 로직 파악이 어려워질 수 있습니다. 특히 의존성 배열 관리나, memo값 이름짓기 등으로 간결함이 깨질 수 있습니다.
- **React.memo 주의:** React.memo로 컴포넌트를 감싸면, props 비교를 `===`로 얕게 합니다. 만약 props로 객체/배열을 넘기고 그 참조가 매번 달라지면 (immutable pattern), memo의 효과가 없습니다. 그리고 비교 자체도 비용이 있으므로, props 개수가 많으면 역효과일 수 있습니다 ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=All%20react%20components%20implement%20the,of%20the%20state%20and%20props)) ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=Looking%20at%20the%20documentation%20on,shallow%20comparison%20on%20every%20update)).
- **디버깅 복잡도:** 메모이제이션이 잘못되면, state는 바뀌었는데 UI가 안 바뀌는 버그가 생길 수 있습니다 (deps 배열 빠뜨림 등). 이런 경우 원인 파악이 초보자에게 어려울 수 있습니다. 린트 규칙으로 deps 관리에 신경써야 합니다.

> **권장 사항:** 공식 문서와 커뮤니티에서는 *"성능 문제를 **발견한 후에** useMemo/useCallback을 적용하라"*고 조언합니다 ([javascript - When to use useMemo and useCallback for performance optimization? - Stack Overflow](https://stackoverflow.com/questions/65020098/when-to-use-usememo-and-usecallback-for-performance-optimization#:~:text=2)). 무턱대고 모든 함수를 useCallback할 필요가 없으며, 실제로 **자식이 불필요하게 자주 렌더되는 병목**이 발견될 때 적용하는 식으로 최적화를 해야 합니다 ([javascript - When to use useMemo and useCallback for performance optimization? - Stack Overflow](https://stackoverflow.com/questions/65020098/when-to-use-usememo-and-usecallback-for-performance-optimization#:~:text=I%20think%20generally%20it%20is,sayHello)). React 팀도 *"memoization은 컴포넌트가 동일 props로 자주 렌더될 때만 가치가 있다"*고 명시했습니다 ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=As%20of%202023%2C%20the%20official,Should%20you%20add%20memo%20everywhere)) ([javascript - When should you NOT use React memo? - Stack Overflow](https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo#:~:text=,rendering%20logic%20is%20expensive)).

### 커스텀 훅 유틸리티 모음 (Common Utility Hooks)

**개요:** React 커뮤니티에는 여러 편리한 **유틸리티 훅**들이 존재합니다. 이들은 특정 기능을 쉽게 사용하도록 캡슐화한 것으로, 프로젝트마다 직접 만들거나 npm 패키지를 쓰기도 합니다. 예를 들어 **usePrevious**, **useDebounce**, **useThrottle**, **useFetch**, **useEventListener**, **useOnScreen(요소 가시성 체크)** 등 수많은 훅들이 개발되어 왔습니다. 이러한 유틸 훅 패턴을 적극 활용하면 반복되는 boilerplate 없이 필요한 기능을 바로 가져다 쓸 수 있어 생산성이 높아집니다.

**사용 사례 (대표적인 커스텀 훅 유틸들):**

- **usePrevious(value)**: 현재 값의 이전 값을 기억해두는 훅. 이전 렌더의 값을 비교하거나 애니메이션 초기값 등에 활용. 구현은 useRef로 값 저장 후 render 후 업데이트.
- **useDebounce(value, delay)**: 어떤 상태 값이 변경될 때, 지정한 지연시간이 지나기 전에 또 변경되면 타이머를 리셋하여 최종 안정된 값만 돌려주는 훅. 검색 입력 같은 곳에서 사용. (내부적으로 useEffect에 타이머 사용)
- **useThrottle(value, delay)**: debounce와 반대로, 값 변경이 너무 자주 일어날 때 일정 주기마다 한 번씩만 최신값을 업데이트해 주는 훅. 스크롤 위치 등의 처리에 활용.
- **useLocalStorage(key, initial)**: 앞서 예시한 것처럼 state를 localStorage와 동기화하는 훅. 페이지 새로고침해도 상태 유지 가능.
- **useMediaQuery(query)**: CSS 미디어쿼리 일치 여부를 boolean 상태로 제공. 반응형 디자인 시 유용. 내부적으로 window.matchMedia 사용하고 이벤트 리스너 등록.
- **useEventListener(target, event, handler)**: DOM 이벤트 핸들러를 간편하게 등록/해제하는 훅. useEffect 내에서 addEventListener, cleanup시 remove.
- **useToggle(initial)**: 불린 값을 true/false 토글하는 간단한 훅. `[value, toggleValue]` 반환.
- **useWhyDidYouUpdate(componentName, props)**: 디버깅용으로, 전달된 props들을 이전과 비교해 어떤 prop이 바뀌어서 업데이트됐는지 콘솔에 로깅해주는 훅. 개발 단계에서 유용.

**장점:**

- **생산성 향상:** 이런 유틸 훅들을 만들어두거나 가져다 쓰면, 반복적인 코드를 매번 작성하지 않아도 됩니다. 프로젝트의 **일관성**도 높아지고, 시간 절약됩니다.
- **코드 가독성:** 훅 이름으로 의도가 드러나기 때문에, `useDebounce(searchTerm, 500)`만 보고도 "아 0.5초 디바운스 하는구나" 알 수 있습니다. 구현 상세는 훅 내부에 감춰지므로 컴포넌트 코드가 깔끔해집니다.
- **커뮤니티 검증:** 널리 쓰이는 훅은 블로그나 라이브러리에 구현이 검증되어 있어, 직접 짜는 것보다 버그가 적고 최적화도 잘 되어 있을 가능성이 높습니다.
- **테스트 용이:** 로직이 훅으로 분리되면, 컴포넌트 UI와 분리되어 테스트하기 더 쉽습니다. (React Hooks testing library 등을 이용)

**단점:**

- **남용시 의존성 증가:** 유틸 훅들을 외부 라이브러리로 많이 쓰면, 프로젝트 dependency가 늘어납니다. 버전 관리나 유지보수에 신경써야 합니다. 직접 작성하면 그 시간과 코드량이 또 부담.
- **추상화 학습 필요:** 팀원 모두가 해당 훅의 존재와 사용법을 알아야 합니다. 그렇지 않으면 커스텀 훅이 내부에서 뭘 하는지 몰라 디버깅이 어려워질 수 있습니다.
- **일부 성능/정확도 한계:** useDebounce 같은 훅은 이벤트 기반이 아닌 state 기반으로 동작하므로, 완벽한 제어는 어려울 수 있습니다. (예: 마지막 호출 시각 등을 세밀히 다루려면 추가 로직 필요)
- **React Hooks 규칙 준수:** 훅 내부에서 훅을 쓰는 패턴이기 때문에, 훅 작성시 규칙(조건부 호출 안됨 등)을 잘 지켜야 하며, 그렇지 않으면 사용 쪽에서 이상한 에러가 날 수 있습니다.

**예시 – useDebounce 구현 간략:**

```tsx
function useDebounce<T>(value: T, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const handler = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(handler);
  }, [value, delay]);
  return debouncedValue;
}
```

위처럼 구현되고, 사용 측은 `const debouncedSearch = useDebounce(search, 300)` 으로 얻어 쓰면 됩니다.

### 불변성 및 상태 업데이트 유틸 (Immer 등)

**개요:** React 상태는 불변성을 지켜 업데이트해야 하는데, 이를 도와주는 유틸리티들이 있습니다. 예를 들어 **Immer.js**는 JS 객체를 마치 가변처럼 편집할 수 있게 해주고 내부에서 불변 사본을 만들어 줍니다. 또한 `useReducer`와 함께 Immer를 사용하면 복잡한 상태 업데이트 로직을 간결히 표현할 수 있습니다. 이외에도 lodash의 `cloneDeep`이나 `_.merge` 등을 사용하기도 하지만, Immer가 더 현대적이고 React와 잘 맞습니다. 이러한 유틸 활용으로 깊은 상태 트리 업데이트를 편하게 하는 패턴이 있습니다.

**사용 사례:**

- **깊은 중첩 상태 변경**: state 객체가 중첩 구조일 때, 불변 업데이트를 직접 하려면 스프레드(...) 문법이나 객체 펼쳐서 복사하는 코드가 복잡해집니다. Immer의 `produce`를 쓰면 draft 객체를 받아 `draft.user.profile.name = "x"` 이런 식으로 직접 할당해도 내부에서 불변 처리를 해줍니다.
- **Reducer와 함께**: Redux Toolkit이 내부적으로 Immer를 사용하듯이, 우리도 `useReducer`로 state 관리 시 reducer 함수 내에서 Immer produce를 사용해 코드를 깔끔히 할 수 있습니다. 예:
  ```js
  const reducer = produce((draft, action) => {
    switch (action.type) {
      case "increment":
        draft.count += 1;
        break;
      case "addTodo":
        draft.todos.push(action.payload);
        break;
    }
  });
  ```
  이런 식으로 draft 조작만 적어주면 됩니다.
- **불변 Array 조작 유틸**: Immer 없이도, `array.map`, `filter`, `slice`, `...spread` 등으로 불변성을 유지해야 합니다. 이때 Lodash 같은 라이브러리의 함수들(_.concat, _.without 등) 써도 되고, 내장 API 잘 써도 됩니다. 핵심은 **mutate 대신 새로운 객체/배열을 만들기** 패턴입니다.

**장점:**

- **코드 간결성:** 특히 Immer를 쓰면, 깊은 구조 업데이트가 **마치 mutable 코드처럼** 보이지만 실제로는 불변 업데이트가 되므로, 개발자 입장에서 생각하기 쉽고 코드도 짧아집니다.
- **실수 방지:** 불변성 유틸은 잘못 mutate하는 실수를 줄여줍니다. Immer draft 외의 변수에 직접 할당하면 오류를 내는 등 개발 시점에 피드백을 줍니다.
- **시간 여행 등 기능 호환:** 상태 불변성이 유지되면 React DevTools나 Redux DevTools에서 변경 감지, 이전 상태 비교 등이 확실해집니다.
- **성능 최적화와 맞물림:** 불변으로 관리하면 React.memo나 PureComponent와 궁합이 좋아 성능상 이점이 있습니다. Immer는 필요 부분만 새로 shallow copy 하므로, 불변 처리 비용도 최적화하는 경향이 있습니다.

**단점:**

- **러닝커브/추가의존성:** Immer 문법(draft 사용) 등을 새로 배워야 합니다. 프로젝트에 새로운 dependency를 추가하는 것이 싫다면, 수동으로 관리해야 하고 그만큼 코딩량과 실수 가능성이 늘죠.
- **추적 어려움:** Immer를 사용하면 내부에서 복잡하게 불변 처리하므로, 디버깅 시에 draft와 최종 결과를 잘 이해해야 합니다. 익숙치 않으면 "어떻게 이게 동작하지?" 할 수 있습니다.
- **성능 오버헤드:** Immer는 Proxy를 활용하여 작업하므로, 굉장히 빈번한 작은 업데이트에는 약간 오버헤드가 있을 수 있습니다. (보통은 미미하지만). 작은 규모에서는 그냥 직접 불변 처리하는 게 더 가볍습니다.
- **Size 증가:** Immer는 gzipped 5KB 정도로 가볍지만, 아주 성능 민감하고 크기 최적화된 환경에선 그마저도 고려 대상이 될 수 있습니다.

**예시 – Immer 없이 vs Immer:**

불변성 수동 처리:

```jsx
// state = { user: { profile: { name: "", age: 0 } } }
setState((prev) => ({
  ...prev,
  user: {
    ...prev.user,
    profile: {
      ...prev.user.profile,
      name: newName,
    },
  },
}));
```

Immer 사용:

```jsx
setState(
  produce((draft) => {
    draft.user.profile.name = newName;
  })
);
```

둘은 동일한 효과인데, Immer가 훨씬 보기 쉽습니다.

### 클래스네임 유틸리티 (조건부 스타일 적용)

**개요:** React에서 엘리먼트에 `className`을 적용할 때, 조건부로 여러 클래스를 조합해야 하는 경우가 많습니다. 이를 위해 **classnames** 또는 **clsx** 라이브러리를 사용하는 패턴이 흔합니다. 예를 들어 `classNames("btn", { "btn-active": isActive, "btn-disabled": disabled })` 식으로 쓰면, true인 키만 클래스 문자열에 포함시켜줍니다. 이 유틸은 작지만 유용해서 거의 모든 프로젝트에 등장하는 패턴입니다. Tailwind CSS를 사용할 때도 조건부 클래스를 조합하는데 classnames를 쓰면 편합니다.

**사용 사례:**

- **여러 클래스 병합:** `className` 문자열을 수동으로 연결하면 `"foo " + (cond ? "bar " : "") + (otherCond ? "baz" : "")` 처럼 지저분해집니다. classnames 유틸을 쓰면 가독성이 좋아집니다.
- **모듈식 CSS (CSS Modules):** CSS Modules를 사용하면 클래스를 import한 객체로 관리하는데, classnames로 모듈 객체 속성들을 넣어 조합할 수 있습니다.
- **Tailwind CSS**: Tailwind 클래스들을 조건부 적용하거나 default + conditional 조합 시 유틸 활용. 예: `clsx("p-4 text-xl", isError && "text-red-500")`.
- **스타일링 기반 패턴**: BEM 방법론처럼 modifier 클래스 붙이고 떼고 하는 경우 classnames로 처리.

**장점:**

- **문법 간결**: 객체 리터럴 또는 배열 형태로 조건부 클래스를 지정하므로, 코드가 깔끔하고 직관적입니다.
- **Falsy 무시**: `false`, `undefined`, `null` 등은 자동 무시되므로, `clsx("class1", cond && "class2")`에서 cond가 false이면 class2는 빼고 처리합니다. 이 패턴은 매우 편리합니다.
- **유연성**: 문자열, 배열, 객체 모두 인자로 섞어 쓸 수 있어서 다양한 상황을 하나의 함수로 처리 가능합니다.
- **경량**: classnames/clsx 모두 수백 바이트~1KB 수준으로 매우 가벼워 부담 없이 쓸 수 있습니다.

**단점:**

- **새 DSL 학습?** 사실 거의 없지만, 객체 키에 true/false로 클래스 적용한다는 개념을 처음엔 이해해야 합니다. (금방 익히지만)
- **추가 함수 호출**: micro-optimization 관점에선 그냥 템플릿 리터럴로 합치는 것보다 함수 호출이 하나 늘어난다는 정도. 일반적으론 무시해도 될 수준입니다.
- **Typescript 지원 약함**: classnames 패키지는 TS 타이핑이 잘 되어 있지만, CSS Module 객체랑 함께 쓰면 타입 안전이 떨어지거나 any 처리되는 경우가 있습니다. (clsx는 제네릭을 써서 나은 편)
- **템플릿 리터럴 대안**: ES6 템플릿 문자열과 conditional 표현도 충분히 가독성 있을 때도 있어서, 꼭 라이브러리가 아니어도 될 경우도 있습니다. 그러나 다수 클래스 조합에는 여전히 classnames가 더 나음.

**예시:**

```jsx
import clsx from "clsx";
// ...
<div
  className={clsx("alert", `alert-${type}`, {
    "alert-dismissible": dismissible,
    hidden: !visible,
  })}
>
  {message}
</div>;
```

위 코드에서는 `type` 변수에 따라 `alert-success`, `alert-error` 등 동적으로 클래스가 추가되고, `dismissible`이 true이면 'alert-dismissible' 클래스 포함, `visible`이 false이면 'hidden' 클래스 추가 등 깔끔하게 표현되고 있습니다.

### Atomic CSS (Tailwind) 패턴

**개요:** 스타일 패턴 측면에서 **Utility-first CSS**로 불리는 Tailwind CSS도 큰 흐름입니다. Tailwind는 작은 원자적 클래스들을 HTML에 직접 붙여 스타일링하는 방식입니다. React와도 궁합이 좋아, 별도 CSS 파일 없이 JSX에 className로 Tailwind 클래스를 적어주면 됩니다. 이 패턴은 CSS-in-JS와는 다르지만, React 개발 시 **스타일을 컴포넌트와 함께** 작성할 수 있다는 장점이 있어 많은 프로젝트에서 채택합니다. Atomic CSS 패턴의 특징은 **반복을 허용**하고 **디자인 일관성**을 유틸 클래스들이 강제한다는 것입니다.

**사용 사례:**

- **빠른 UI 프로토타이핑:** Tailwind는 미리 디자인 시스템에 맞춘 수백개의 유틸 클래스 (간격, 색상, 폰트 등)를 제공하므로, 컴포넌트에 className만 잘 조합하면 빠르게 UI를 만들 수 있습니다. React 컴포넌트에서 바로 스타일 작업하기 좋습니다.
- **디자인 시스템 없이 시작할 때:** 디자이너 없이 개발 주도로 UI 만들 때, Tailwind 유틸로 적당히 보이는 UI를 만들고 나중에 다듬기 편합니다.
- **일관성 유지:** padding, margin, color 값을 클래스 기준으로 통일하므로, 임의 값 쓰는걸 피하고 일관성 확보. (예: `p-4`는 1rem padding, `text-lg`는 특정 크기 등).
- **조건부 스타일 쉽게:** React에서 state나 props에 따라 클래스 토글해야 할 때, classnames 유틸과 Tailwind를 조합하면, runtime에 복잡한 JS 없이도 표현 가능. (ex: `clsx("bg-white", darkMode && "bg-gray-800")`).

**장점:**

- **생산성 & 일관성:** 미리 만들어진 스타일 조각들을 조합하는 것이므로, custom CSS를 쓰는 것보다 신속합니다. 또한 디폴트 spacing, color scale이 있으니 전체 앱의 룩앤필이 일관되기 쉽습니다.
- **파일 최소화:** 별도 CSS 파일을 거의 안쓰니, 스타일 충돌이나 전역 CSS 부작용이 원천 차단됩니다. className 수준에서만 스타일 적용되므로 **scoped**한 효과.
- **반복 허용의 미덕:** 일반적으로 CSS에서는 같은 값 반복 정의를 안좋게 보지만, Tailwind에서는 유틸 클래스 재사용이라 오히려 권장됩니다. 이는 사이즈도 크게 늘리지 않으면서도, 개발자 사고를 단순화합니다 (필요한 것 골라 쓰면 되니).
- **JSX에 내재:** 스타일 정의가 컴포넌트 JSX 내부에 있기 때문에, 한 눈에 해당 컴포넌트의 구조와 스타일을 함께 볼 수 있습니다. 스타일 수정시에도 관련 JSX를 바로 수정하면 되어 맥락 전환이 적습니다.

**단점:**

- **가독성 논란:** HTML(및 JSX)에 너무 많은 클래스가 붙어 지저분해 보일 수 있습니다. 특히 Tailwind 처음 보는 사람은 `class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded"` 이런 걸 보면 복잡해 보입니다.
- **추상화 낮음:** 유틸 클래스는 로우레벨 스타일 요소라, 의미적인 클래스 이름(BEM의 .btn-primary 등)이 없어서, 같은 패턴의 스타일이 여러 군데서 반복될 수 있습니다. (해결: Tailwind의 @apply로 커스텀 유틸 만들기도 함)
- **디자이너 협업 난점:** 디자이너들은 CSS로 스타일 명세를 보거나 Zeplin 등으로 픽셀 단위 지시하는데, 개발자는 Tailwind 클래스 용어로 바꿔야 해서 번역 작업이 있습니다. 디자이너도 Tailwind 스펙을 알아야 서로 소통 원활.
- **빌드 의존성:** Tailwind 사용하려면 PostCSS 설정이나 CLI 등을 거쳐야 하고, 프로덕션 빌드시 purge(사용된 클래스만 추출) 과정이 필요합니다. 초기 설정과 빌드시간 비용이 있습니다.

**결론:** 스타일 패턴에는 **CSS Modules**, **CSS-in-JS(Styled-Components, Emotion)**, **Atomic CSS(Tailwind)**, **전통적 SCSS + BEM** 등이 있습니다. 프로젝트 성격과 팀 선호에 따라 선택하지만, **모듈화**와 **유지보수** 측면에서 각각 장단이 있으므로, 하나를 채택했다면 그 패턴을 일관되게 따르는 것이 중요합니다.

## 스타일 패턴 (Styling Patterns)

React에서 스타일을 적용하는 방법은 다양합니다. 여기서는 주요 스타일 패턴들인 **전통적 CSS/SCSS + BEM**, **CSS Modules**, **CSS-in-JS (Styled Components 등)**, **Utility-First CSS (Tailwind)** 등의 접근을 살펴보고, Next.js 환경에서 주로 사용되는 방법들의 예시, 장단점을 비교합니다.

### CSS Modules 패턴

**개요:** **CSS Modules**는 `.module.css` (또는 .module.scss) 파일을 import 하면, 클래스명을 **고유한 해시된 식별자**로 변환해주는 방식입니다. 이로써 CSS 클래스가 기본적으로 **컴포넌트 단위로 범위가 한정(Scoped)**됩니다. Next.js에서는 CSS Modules를 기본 지원하므로, `styles/Button.module.css` 파일을 만들어 `import styles from './Button.module.css'`하면 `styles.btn`처럼 객체 속성으로 사용 가능합니다. CSS Modules는 **전역 네임스페이스 충돌을 방지**하고, BEM 없이도 각 컴포넌트 스타일을 캡슐화할 수 있는 패턴입니다.

**사용 사례:**

- **컴포넌트별 스타일 분리:** 컴포넌트 파일과 나란히 module.css 파일을 두고, 그 컴포넌트 전용 스타일을 작성합니다. 클래스 이름은 짧게(`.container`, `.title` 등) 해도 실제로는 빌드 시 유일한 이름 (e.g. `Button_container__abc123`)으로 바뀌므로 충돌 걱정 없습니다 ([CSS Modules vs. Styled Components for Styling in Next.js - DEV Community](https://dev.to/swhabitation/css-modules-vs-styled-components-for-styling-in-nextjs-1p04#:~:text=Comparing%20CSS%20Modules%20And%20Styled,Components)).
- **Next.js 글로벌+로컬 혼합:** Next.js App Router에서 전역 스타일 (e.g. globals.css)은 일반 CSS로 두고, 나머지 컴포넌트 스타일은 Module로 구성해 관리합니다.
- **조건부 클래스**: CSS Modules 결과는 JS 객체이므로, classnames 유틸을 쓰면 { [styles.active]: isActive } 이런 식으로 모듈 클래스도 간단히 토글 가능합니다.

**장점:**

- **스코프 보장:** 클래스 이름 충돌이 원천적으로 방지됩니다 ([CSS Modules vs. Styled Components for Styling in Next.js - DEV Community](https://dev.to/swhabitation/css-modules-vs-styled-components-for-styling-in-nextjs-1p04#:~:text=,gives%20scoped%20styling%20by%20default)). 여러 사람이 작업해도 클래스명이 겹쳐도 문제없어, 협업이 편합니다.
- **전통 CSS 활용:** 순수 CSS/SCSS 문법을 그대로 사용하므로, 기존 CSS 지식을 모두 활용할 수 있습니다. :global, :local 키워드로 범위 조절도 가능하고, 미디어쿼리, keyframes 등 제한 없이 작성 가능합니다.
- **경량 런타임:** CSS Modules는 빌드 타임에 클래스명 변환만 일어나고, 런타임 오버헤드가 없습니다. 스타일 적용은 일반 `<style>` 혹은 CSS 파일 링크로 되어 성능상 이점이 있습니다.
- **Type Safety (with TS)**: `d.ts` 생성 설정을 하면 `styles` 객체에 존재하는 클래스명만 자동완성되고, 틀리면 에러가 나서 타입 안전성을 얻을 수 있습니다.

**단점:**

- **스타일 분산:** JS와 CSS 파일이 분리되므로, 컴포넌트 구조와 스타일을 오가며 봐야 합니다 (일부 IDE/extension은 module CSS를 inline으로 보여주기도 함).
- **동적 스타일 한계:** JS 변수로 계산한 값을 CSS로 전달하기 까다롭습니다. (CSS custom properties나 inline style로 보완해야) CSS-in-JS에 비하면 JS와 스타일간 인터랙션이 제한적입니다.
- **학습 비용 거의 없음:** (큰 단점은 아니지만) 팀원이 CSS Modules의 개념 (특히 composition이나 global scope 작성법 정도)을 알아야 합니다.
- **추적성:** className이 빌드 시 바뀌므로, 크롬 DevTools에서 요소의 클래스명을 보고 직접 검색해 찾긴 어렵습니다. (단, Next dev 모드에선 원본이 보이긴 함). 또한 React DevTools로는 스타일 확인 못하고 Elements 패널 봐야 해서, styled-components처럼 바로 컴포넌트에서 스타일 추적은 안됩니다.

### Styled-Components / CSS-in-JS 패턴

**개요:** **CSS-in-JS**는 JS 파일 안에 CSS를 작성하고, 런타임에 이를 style 태그로 삽입하는 방식입니다. 대표적으로 **Styled Components**와 **Emotion** 라이브러리가 널리 쓰입니다. Styled Components는 Tagged Template Literals 문법으로 CSS를 정의하며, 실제로는 React 컴포넌트로 사용됩니다. 예: `const Button = styled.button\`background: blue; color: white;\`;`이렇게 정의하고

`<Button>`을 JSX에 쓰면, 자동으로 `<button class="sc-xyz">`가 렌더되고 해당 클래스 스타일이 head에 주입됩니다. CSS-in-JS 패턴은 **컴포넌트와 스타일을 한 파일에 결합**하고, **동적 스타일** (props에 따른 CSS 변경 등)을 쉽게 적용할 수 있다는 장점이 있습니다.

**사용 사례:**

- **디자인 시스템**: Styled-components로 기본 UI 구성 요소(Button, Card 등)를 만들고, 테마를 정의하여 ThemeProvider로 색상/폰트를 공급, 전체에 일관된 스타일을 적용합니다.
- **Props 기반 스타일:** 컴포넌트 props에 따라 스타일 변경이 필요한 경우, styled-components에서 함수로 처리합니다. e.g. `styled.div\`background: \${props => props.active ? 'red' : 'gray'};\``
- **Global Style 및 Keyframes:** styled-components는 `createGlobalStyle` API로 전역 CSS 정의나 `keyframes` 함수로 애니메이션 정의 등을 제공합니다. 이로써 CSS 작업을 다 JS 내에서 가능하게 합니다. Next.js에서도 styled-components SSR을 위한 Babel 설정 등을 종종 합니다 (스타일을 SSR로 미리 내보내 플래시 방지).

**장점:**

- **완전한 CSS 표현력 + JS 파워:** CSS-in-JS는 전통 CSS의 모든 기능 (미디어쿼리, 키프레임 등) + JS의 조건, 변수 삽입 등을 모두 사용할 수 있어 **표현력이 최고**입니다. props나 theme를 활용해 동적인 스타일도 손쉽게 구현됩니다 ([CSS Modules vs. Styled Components for Styling in Next.js - DEV Community](https://dev.to/swhabitation/css-modules-vs-styled-components-for-styling-in-nextjs-1p04#:~:text=Styled%20Components%20are%20dynamic%2C%20meaning,styles%20based%20on%20those%20props)) ([CSS Modules vs. Styled Components for Styling in Next.js - DEV Community](https://dev.to/swhabitation/css-modules-vs-styled-components-for-styling-in-nextjs-1p04#:~:text=,gives%20scoped%20styling%20by%20default)).
- **컴포넌트 기반 스타일링:** 스타일을 적용한 결과물이 React 컴포넌트이므로, JSX에서 일반 컴포넌트 쓰듯이 사용할 수 있습니다. 이는 논리와 스타일을 강하게 결속시켜 **응집도**를 높입니다.
- **삭제 안된 CSS 최소화:** CSS Modules나 전통 CSS에서는 사용안하는 클래스도 남아있을 수 있지만, CSS-in-JS는 컴포넌트가 언마운트되면 그 스타일을 제거하는 등 관리가 가능합니다 (styled-components는 styled component 별로 snapshot, remove가 있음).
- **개발 편의:** 스타일을 JS안에서 작성하므로, 변수 및 자동완성 혜택, 리터럴 내 편집기 CSS 하이라이팅 등 지원도 좋습니다. styled-components의 VSCode extension은 CSS 문법을 템플릿 리터럴 안에서 지원합니다.

**단점:**

- **런타임 오버헤드:** CSS-in-JS는 JS로 CSS 문자열을 처리하고 스타일 태그 삽입을 런타임에 하므로, **초기 로드 성능**에 영향이 있습니다. 특히 스타일이 많은 앱에서는 SSR+hydration 단계에서 성능 문제 보고가 있었습니다.
- **파일 크기 증가:** styled-components 라이브러리 자체가 수 kB (gzip ~11KB) 있고, 사용하는 만큼 runtime 코드가 실행됩니다. 바닐라 CSS 대비 JS 번들 사이즈 증가가 불가피합니다.
- **스타일 디버깅:** DevTools 요소에 붙은 클래스명이 해시로 나오기 때문에, 어떤 styled component인지 한눈에 모를 수 있습니다 (해결: babel-plugin나 style component dev mode는 component명 포함함).
- **습득 필요:** Tagged template literal 문법, ThemeProvider, attrs 등의 API 등 Styled-components 고유의 문법을 배워야 합니다. 새로운 팀원이 바로 이해하긴 약간 진입장벽이 있습니다.
- **Next.js SSR설정:** Next.js에서 styled-components SSR을 지원하려면 `_document.js`에 ServerStyleSheet 코드를 추가해 collectStyles 하는 등의 설정이 필요합니다. (최근엔 SWC 플러그인으로 자동도 가능).

### 기타: 전통 CSS + BEM, Inline Style 등

**개요:** 마지막으로, **전통적인 CSS 사용 패턴**과 **Inline Style**에 대해 언급합니다.

- **전통 CSS + BEM:** React 이전 방식처럼, 전역 CSS (혹은 SCSS)를 작성하고, 클래스명을 `block__element--modifier` 같은 BEM 규칙으로 지어서 충돌을 피하는 방법입니다. React 컴포넌트에도 여전히 적용 가능하며, 소규모 프로젝트나 디자이너 주도 스타일링 시 사용됩니다. 장점은 특별한 도구 없이 기존 CSS 역량으로 가능하고, DevTools에서 클래스명 보면 바로 CSS 파일에서 찾을 수 있다는 점입니다. 단점은 전역 네임스페이스 관리 어려움, React 컴포넌트 재사용 시 스타일 종속성 문제가 있을 수 있습니다.

- **Inline Style:** JSX 요소의 `style` prop에 JS 객체로 스타일을 직접 넣는 방법입니다. 예: `<div style={{ backgroundColor: 'red', padding: 10 }}>`. 이 방식은 JavaScript로 모든 것을 제어하기에 동적 계산에는 편하나, CSS 많은 기능(특히 :hover, 미디어쿼리, keyframes)을 지원 못합니다. 그리고 성능 면에서 많은 요소에 inline style 주면 재렌더 시 계속 객체 새로 만들어야 해서 비효율적입니다. 일반적으로 Inline style은 **동적으로 계산된 한두 가지 속성** (예: 좌표, width 등) 적용에만 쓰이고, 전체 스타일링에는 쓰지 않는 것이 권장됩니다.

**비교 요약:**

- **전통 CSS (글로벌) + BEM:** _장점:_ 쉽고 검증된 방법, 외부 CSS/디자이너 협업 용이. _단점:_ 클래스 충돌 가능성, 컴포넌트 캡슐화 저해.
- **CSS Modules:** _장점:_ 클래스 충돌X, 기존 CSS 활용. _단점:_ JS와 분리.
- **CSS-in-JS (Styled):** _장점:_ JS로 동적 스타일, 컴포넌트 단위 관리. _단점:_ 성능오버헤드, 러닝커브.
- **Utility CSS (Tailwind):** _장점:_ 빠른 개발, 일관성, 클래스 충돌X. _단점:_ HTML 클래스 장황, 커스텀 디자인에 한계.
- **Inline style:** _장점:_ JS에서 동적 계산 쉬움. _단점:_ 한정된 CSS 기능, 성능 문제.

프로젝트에 맞게 이러한 스타일 패턴을 선택하거나 혼합하여 사용할 수 있습니다. Next.js 앱에서는 보통 CSS Modules나 CSS-in-JS, Tailwind 중 하나를 선택해 전역 스타일과 컴포넌트 스타일을 구성합니다. 각각의 접근은 코드 구조와 개발 경험에 영향을 미치므로, 팀 구성원들의 익숙함과 프로젝트 요구사항을 고려해 결정하는 것이 좋습니다.

---

이상으로 React에서 자주 사용되는 핵심 패턴들을 범주별로 정리했습니다. **컴포넌트 합성**, **상태 관리**, **고급 구성 기법**, **비동기 처리**, **유틸리티 활용**, **스타일링**까지 폭넓은 패턴들을 살펴보았는데, 실제 프로젝트에서는 이 중 여러 패턴을 상황에 맞게 조합하여 사용하게 됩니다. 중요한 것은 각각의 패턴이 **어떤 문제를 해결하기 위해 나왔는지 이해**하고, **필요한 시점에 적절히 적용**하는 것입니다. 최신 React (18+)와 Next.js 환경에서는 소개한 많은 패턴들이 Hooks와 Concurrent features를 통해 더욱 편리하게 구현되며 계속 진화하고 있습니다. 이 문서를 참고하여 React 패턴들에 대한 감을 잡고, 실전에서 유용하게 활용하시길 바랍니다.

**참고 자료:** React 공식 문서 및 커뮤니티 블로그, Next.js 공식 가이드 등. (각 섹션에 출처 표기)

## 추가

## 1.5 Slot Pattern (asChild)

### 💡 개념

Slot 패턴은 부모 컴포넌트가 자식의 DOM 요소를 직접 제어할 수 있도록 위임하는 방식입니다. `asChild`를 활용하여 DOM 요소를 교체하거나 직접 스타일을 입힐 수 있게 만드는 방식이 대표적입니다.

### 🔍 대표 사례

- ShadCN UI의 `asChild` prop
- Radix UI

### ✅ 특징

- 부모 컴포넌트가 렌더링할 실제 DOM 요소를 자식으로부터 위임받음
- HTML 구조의 중복 제거 및 스타일 유연성 확보

### 📦 예시

```tsx
<Button asChild>
  <Link href="/dashboard">Go to Dashboard</Link>
</Button>
```

---

## 2.5 Global State with Hooks

### 💡 개념

Context API, Zustand, Jotai 등 훅 기반으로 전역 상태를 관리하는 패턴입니다.

### ✅ 특징

- 앱 전체에서 상태를 공유 가능
- 서버 상태와 클라이언트 상태를 구분하기 쉬움
- React 컴포넌트 트리와 밀접하게 통합됨

### 📦 예시

```tsx
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

function Counter() {
  const count = useStore((state) => state.count);
  return <div>{count}</div>;
}
```

---

## 3.3 Hook Factory

### 💡 개념

공통된 로직이나 패턴을 함수화하여, 동적으로 훅을 생성하는 고급 기법입니다.

### ✅ 특징

- 네임스페이스 기반 상태 생성 가능
- 코드 중복 최소화

### 📦 예시

```tsx
const createUseStore = (namespace: string) => () => {
  return useStore((state) => state[namespace]);
};

const useSidebarStore = createUseStore("sidebar");
```

---

## 3.5 Headless Component Pattern

### 💡 개념

UI는 제공하지 않고, 상태 및 동작만 제공하는 컴포넌트 패턴입니다.

### 🔍 대표 사례

- Radix UI
- Headless UI

### ✅ 특징

- 완전한 커스터마이징 가능
- 디자인 시스템에 독립적

### 📦 예시

```tsx
<Popover>
  <PopoverTrigger>열기</PopoverTrigger>
  <PopoverContent>내용</PopoverContent>
</Popover>
```

---

## 3.6 Dependency Injection via Props

### 💡 개념

부모가 자식에게 함수나 컴포넌트를 props로 넘겨서 원하는 행위를 위임하는 방식입니다.

### ✅ 특징

- 테스트하기 쉬움
- 유연성 높음

### 📦 예시

```tsx
function List({ items, renderItem }) {
  return <ul>{items.map(renderItem)}</ul>;
}

<List items={[1, 2, 3]} renderItem={(item) => <li key={item}>{item}</li>} />;
```

---

## 4.2 Skeleton Pattern

### 💡 개념

데이터 로딩 중에 뼈대 UI(skeleton)를 먼저 보여주는 패턴입니다.

### ✅ 특징

- 사용자 경험 개선
- 로딩 지연에 대비한 대비책

### 📦 예시

```tsx
{
  isLoading ? <Skeleton className="h-4 w-[250px]" /> : <p>{data}</p>;
}
```

---

## 4.3 Progressive Hydration

### 💡 개념

React의 클라이언트 Hydration을 점진적으로 적용하여 초기 로드 성능을 개선하는 기법입니다.

### ✅ 특징

- 서버 렌더링 우선
- 점진적 기능 부트스트랩

### 📦 예시 (Next.js App Router 기준)

```tsx
"use client";

import dynamic from "next/dynamic";
const CommentSection = dynamic(() => import("./CommentSection"), {
  ssr: false,
});
```

---

## 6.3 Scoped Slot + Variant

### 💡 개념

ShadCN 또는 Headless UI에서 제공하는 상태 기반 Variant 및 Slot 시스템

### ✅ 특징

- 상태(`variant`, `size` 등)에 따라 클래스를 조건부로 지정
- slot을 통해 스타일 범위 제어 가능

### 📦 예시

```tsx
<Button variant="outline" size="sm">
  작은 버튼
</Button>
```

---
