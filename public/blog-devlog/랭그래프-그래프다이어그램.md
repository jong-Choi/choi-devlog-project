# 랭그래프(LangGraph) 기반 chat 서비스 구조 분석과 그래프 다이어그램

본 문서는 프로젝트의 `app/api/chat` 백엔드 코드를 기준으로, LangGraph/ LangChain을 활용한 대화 흐름을 기술적으로 분석하고, 사용된 주요 API와 구현 방법을 정리합니다. 마지막에는 아스키/머메이드 두 가지 버전의 그래프 다이어그램을 제공합니다.

## 1) 전체 아키텍처 개요

- **세션 생성**: `POST /api/chat` → `handleConnect()`가 `sessionId`를 발급하고 세션 스토어에 저장. 일정 시간(idle) 후 자동 정리.
- **메시지 전송**: `POST /api/chat/[sessionId]` → `handleSend()`가 세션 상태(State)에 사용자 메시지와 라우트 타입을 저장.
- **스트리밍 실행**: `GET /api/chat/[sessionId]` → `handleStream()`이 LangGraph 애플리케이션을 빌드하고 `streamEvents()`로 이벤트를 SSE로 전송.
- **상태 업데이트**: `PUT /api/chat/[sessionId]` → `handleUpdate()`가 외부에서 전달된 메시지 배열을 그래프 상태에 반영.
- **세션 정리**: `DELETE /api/chat/[sessionId]` → 세션/체크포인터 스레드 삭제.

핵심은 `buildGraph()`가 정의하는 LangGraph의 상태 기계(StateGraph)입니다. 각 노드(chat/simpleChat/google)가 동일한 글로벌 상태를 공유하고, 라우팅 노드가 다음 실행 노드를 결정합니다.

## 2) LangGraph 상태, 그래프, 체크포인터

- `SessionMessagesAnnotation` (전역 상태 스키마)
  - `messages: BaseMessage[]` (LangChain 메시지, reducer: `messagesStateReducer`)
  - `routeType: "chat" | "simpleChat" | "google" | ... | ""` (다음 노드 선택 키)
  - `postId?: string` (게시글 맥락)
- `checkpointer = new MemorySaver()`
  - LangGraph의 체크포인터. `thread_id`(여기서는 `sessionId`) 단위로 상태를 지속화하여 멀티턴, 재시작, 분기 합류를 안정적으로 지원.
- `buildGraph()`
  - `new StateGraph(SessionMessagesAnnotation)`로 상태 그래프 생성
  - 노드 등록: `routing`, `chat`, `simpleChat`, `google`
  - `START -> routing` 엣지로 시작하며, 각 노드는 `Command({ goto, update })`로 다음 이동/상태 갱신을 수행
  - `.compile({ checkpointer })`로 체크포인터와 함께 실행 가능한 앱 객체를 생성

### streamEvents 사용

`handleStream()`은

```ts
for await (const chunk of app.streamEvents(inputs, {
  version: "v2",
  configurable: { thread_id: sessionId },
})) { ... }
```

형태로 LangGraph 실행 이벤트를 스트림합니다. `configurable.thread_id`로 체크포인트 키를 지정하여 세션별 상태를 복구/저장합니다.

## 3) 라우팅과 노드 동작

### routingNode

- 입력 상태의 `routeType`을 읽어 다음 노드를 선택합니다.
- 빈 문자열이면 `END`로 종료. 유효 키면 해당 노드로 `goto`.

### chatNode (컨텍스트 기반 응답)

- 최근 `MAX_MESSAGES_LEN`개 메시지를 자른 뒤, 시스템 프롬프트를 구성합니다.
- `postId`가 있을 경우 `getAISummaryByPostId(postId)`를 호출해 요약문을 시스템 메시지로 추가.
- `llmModel.invoke([...systemPrompt, ...contextMessages])`로 모델 호출 후 `messages`를 최신 AI 응답으로 갱신, `routeType`을 빈 문자열로 비움, 다음 이동을 `routing`으로 지정.

### simpleChatNode (순수 대화)

- 컨텍스트/시스템 추가 없이 `state.messages.slice(0 - MAX_MESSAGES_LEN)`만 모델에 전달.
- 응답을 `messages`로 갱신하고 다시 `routing`으로 이동.

### googleNode (웹 검색)

- 마지막 사용자 발화에서 질의어를 추출.
- Google Custom Search API 호출(`key`, `cx`, `q`, `num`, `fields`)
- 응답 `items`를 zod로 검증 후, `SystemMessage(JSON.stringify(items))`를 추가하고 `routeType`을 `simpleChat`으로 설정하여 다음 차례에 요약/응답하도록 함.

## 4) 이벤트 스트리밍과 SSE 포맷

- `chatEventHander()`는 LangGraph 이벤트(`on_chat_model_start`, `on_chat_model_stream`, `on_chat_model_end`)를 수신해 SSE로 전송합니다.
- 스트리밍 중 미구현 라우트(`summary`, `recommend`)는 `bipassEventHander()`로 즉시 고정 문구를 스트리밍 후 상태를 갱신하도록 구현.

## 5) LangChain 모델 구성(ChatOllama)

- `llmModel = new ChatOllama({ baseUrl, model, streaming: true, fetch, numPredict })`
  - `fetch`를 오버라이드하여 `LLM-SECRET-KEY` 헤더 삽입
  - `numPredict`로 최대 토큰 길이 제한(무한 생성 방지)
  - `streaming: true`로 스트림 이벤트 활성화

## 6) 주요 API/메서드 설명과 구현 팁

- `Annotation.Root({...})`
  - LangGraph 전역 상태 스키마를 정의합니다. 각 필드는 `default`, `reducer`를 가질 수 있습니다.
  - `messagesStateReducer`는 LangChain이 제공하는 메시지 병합 로직으로, 누적 메시지 상태를 일관되게 유지합니다.
- `StateGraph`
  - 상태 스키마를 받아 그래프를 정의합니다. `addNode(name, fn, { ends })`, `addEdge(START, name)` 형태로 흐름을 기술합니다.
- `MemorySaver`
  - 체크포인터 구현체로, `thread_id` 기반 상태 저장/복구를 지원합니다.
- `Command({ goto, update })`
  - 노드 함수의 반환값으로, 다음 이동할 노드 키(`goto`)와 병합할 상태(`update`)를 지정합니다.
- `app.streamEvents(state, { configurable: { thread_id } })`
  - 그래프 실행을 이벤트 스트림 형태로 제공. SSE 등으로 클라이언트에 전송해 토큰 단위 렌더링이 가능합니다.
- `HumanMessage/AIMessage/SystemMessage`
  - LangChain의 메시지 타입. LLM 호출 전후로 표준화된 메시지 형식을 사용하세요.
- `ChatOllama.invoke(messages)`
  - 다중 메시지 프롬프트를 입력으로 받아 1개의 `AIMessage`를 반환. `streaming: true` 설정 시 스트림 이벤트 콜백을 통해 토큰을 점진적으로 수신할 수 있습니다.

구현 시 주의점(간단하지만 중요한 것들)

- 라우트 타입은 빈 문자열로 리셋해야 라우팅이 `END`로 종료되거나 다음 사이클이 의도대로 동작합니다.
- `thread_id`를 세션과 1:1 매핑하여 체크포인트 상태가 섞이지 않도록 합니다.
- 외부 API(예: 구글 검색) 실패 시 다음 노드로 우회하도록 `routeType`을 적절히 설정하십시오.
- 모델 호출 전 시스템/컨텍스트 메시지 순서를 보장하세요. 시스템 → 사용자/어시스턴트 최근순이 일반적입니다.

## 7) 이 프로젝트의 대화 흐름 다이어그램

### ASCII 버전

```
[START]
   |
   v
[routing]
   | routeType == "chat"           | routeType == "google"         | routeType == "simpleChat"
   |                               |                                   |
   v                               v                                   v
[chat] -----------------------> [routing] <---------------------- [simpleChat]
   |                                ^                                   ^
   | (postId 요약 로딩 후           |                                   |
   |  시스템 프롬프트 + 컨텍스트)    |                                   |
   |                                |                                   |
   | routeType = ""                 | routeType = ""                    | routeType = ""
   |                                |                                   |
   +------------------------------> +----------------------------------+

(별도 분기)
[routing] --(routeType=="google")-> [google] --> (items as SystemMessage, routeType="simpleChat") --> [routing]
```

### Mermaid 버전

```mermaid
graph TD
    START((START)) --> ROUTING[Routing Node]

    ROUTING -- chat --> CHAT[Context Chat Node]
    ROUTING -- google --> GOOGLE[Google Node]
    ROUTING -- simpleChat --> SIMPLE[Simple Chat Node]
    ROUTING -- empty --> END((END))

    CHAT -->|update: messages, routeType=""| ROUTING
    SIMPLE -->|update: messages, routeType=""| ROUTING

    GOOGLE -->|SystemMessage(items)\nrouteType="simpleChat"| ROUTING
```

## 8) 참고(키워드)

- LangGraph: Annotation, StateGraph, MemorySaver, Command, START/END, streamEvents
- LangChain JS: BaseMessage, HumanMessage, AIMessage, SystemMessage, messagesStateReducer, ChatOllama
- Google Custom Search API: `key`, `cx`, `q`, `num`, `fields`

필요 시 파이썬 문서의 개념(체크포인팅, 상태 주입, 분기, 토큰 스트리밍)도 JS와 거의 동일한 구조이므로 참조해도 무방합니다.

---

## 9) 기술 스펙 상세

### 라우트 스펙

- `POST /api/chat`
  - 목적: 세션 생성 및 `sessionId` 발급
  - 응답: `{ success: true, data: { sessionId: string } } | 500`
  - 부작용: `sessionStore.set`, idle 타이머 등록, `checkpointer.deleteThread` 예약
- `POST /api/chat/[sessionId]`
  - 목적: 메시지 전송(상태 기록)
  - 바디: `{ message: string; type: RouteType; postId?: string }`
  - 동작: `sessionStore.set({ id, state: { messages:[HumanMessage], routeType, postId } })`
  - 응답: `{ success: true, requestId: string } | 400 | 500`
- `GET /api/chat/[sessionId]`
  - 목적: 그래프 실행 이벤트 스트리밍(SSE)
  - 입력 상태: 세션 스토어에 저장된 `state`
  - 동작: `buildGraph().streamEvents(inputs, { configurable: { thread_id } })`
  - 이벤트: `on_chat_model_start`, `on_chat_model_stream`, `on_chat_model_end`
  - 미구현 라우트: `summary`, `recommend` → 바이패스 고정 응답
- `PUT /api/chat/[sessionId]`
  - 목적: 외부 대화 히스토리로 상태 갱신
  - 바디: `{ messages: ChatMessage[] }`
  - 동작: ChatMessage→LangChain Message 매핑 후 `app.updateState(..., { messages, routeType: "" })`
- `DELETE /api/chat/[sessionId]`
  - 목적: 세션/체크포인트 정리
  - 동작: `sessionStore.delete`, `checkpointer.deleteThread`

### 상태 스키마 스펙

- `SessionMessagesAnnotation`
  - `messages: BaseMessage[]` (기본값: `[]`, reducer: `messagesStateReducer`)
  - `routeType: LangNodeKeys | ""` (기본값: `"chat"`)
  - `postId?: string` (기본값: `undefined`)

### 노드 스펙

- `routingNode(state)`
  - 입력: `routeType`
  - 로직: 빈 문자열→`END`, 그 외→동명 노드로 `goto`
  - 출력: `Command({ goto })`
- `chatNode(state)`
  - 입력: 최근 메시지, 선택적 `postId`
  - 로직:
    - `postId` 있으면 `getAISummaryByPostId` 호출 후 시스템 메시지로 합성
    - `llmModel.invoke(system + context)` 실행
  - 출력: `update: { messages:[AIMessage], routeType:"" }`, `goto: routing`
- `simpleChatNode(state)`
  - 입력: 최근 메시지 슬라이스
  - 로직: `llmModel.invoke(messages)`
  - 출력: `update: { messages:[AIMessage], routeType:"" }`, `goto: routing`
- `googleNode(state)`
  - 입력: 최신 사용자 발화(content)
  - 로직:
    - Google Custom Search API 호출 → `items(title,snippet)` 파싱(zod)
    - 성공: `SystemMessage(JSON.stringify(items))`, `routeType="simpleChat"`
    - 실패: `SystemMessage("일시적인 오류...")`, `routeType="simpleChat"`
  - 출력: `goto: routing`

### 이벤트/스트리밍 스펙

- SSE 데이터 페이로드(`chatEventHander`):
  - start: `{ event:"on_chat_model_start", name:"chatNode" }`
  - stream: `{ event:"on_chat_model_stream", name:"chatNode", chunk:{ content:string } }`
  - end: `{ event:"on_chat_model_end", name:"chatNode" }`
- 바이패스(`bipassEventHander`): start → stream(고정문구) → end 순으로 즉시 전송

### 모델 스펙 (ChatOllama)

- 생성자 옵션:
  - `baseUrl: string` (예: `process.env.ORACLE_OLLAMA_HOST`)
  - `model: string` (HF GGUF 경로 포함)
  - `streaming: true`
  - `fetch: (url, options)=>Response` (비밀키 헤더 주입 등 커스텀)
  - `numPredict: number` (최대 토큰 수)
- 호출:
  - `invoke(messages: BaseMessage[]|RunnableConfig)` → `AIMessage`

### 환경 변수/보안 스펙

- `LLM-SECRET-KEY`: 내부 LLM 게이트웨이 인증용(커스텀 fetch에서 헤더 삽입)
- `ORACLE_OLLAMA_HOST`: Ollama 호스트 URL
- `GOOGLE_SEARCH_API_KEY`, `GOOGLE_SEARCH_CX`: Google CSE 인증
- 유의사항:
  - 서버 로그에 키/응답 전체를 출력하지 않기
  - 외부 API 실패 시 사용자 친화적 메시지와 폴백 경로 유지

### 오류 처리 스펙

- 입력 누락: `400`과 에러 메시지(JSON)
- 내부 오류: `500`과 에러 메시지(JSON)
- 스트림 오류: SSE로 `{ event:"error", message:"..." }` 전송 후 스트림 종료

---

## 10) 참고 문서 및 링크

- LangGraph JS
  - 상태 그래프/어노테이션/체크포인터 개념: `https://langchain-ai.github.io/langgraph/` (Docs Hub)
  - Agents/Graphs 가이드: `https://langchain-ai.github.io/langgraph/agents/agents/`
- LangChain JS
  - 코어 메시지/스트림 이벤트 타입: `https://api.js.langchain.com` (API Reference 검색: StreamEvent, BaseMessage)
  - ChatOllama 가이드/옵션: `https://js.langchain.com/docs/integrations/chat/ollama`
- Google Custom Search API
  - REST 쿼리 파라미터 가이드: `https://developers.google.com/custom-search/v1/overview`

(참고) 일반 개념/비교 글(설명 보조용)

- LangGraph vs LangChain 개요: `https://gunn.kim/langgraph-vs-langchain-evolution-of-llm-development-frameworks`

위 링크는 본 구현의 개념·API를 확인하는 데 사용되었습니다. 실제 동작은 본 리포지토리의 코드 스펙에 맞춰 상세화했습니다.
